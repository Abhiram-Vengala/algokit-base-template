/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils'
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app'
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client'
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec'
import type { SendTransactionResult, TransactionToSign, SendTransactionFrom, SendTransactionParams } from '@algorandfoundation/algokit-utils/types/transaction'
import type { ABIResult, TransactionWithSigner } from 'algosdk'
import { Algodv2, OnApplicationComplete, Transaction, AtomicTransactionComposer, modelsv2 } from 'algosdk'
export const APP_SPEC: AppSpec = {
  "hints": {
    "createApplication(string,string)void": {
      "call_config": {
        "no_op": "CREATE"
      }
    },
    "nft_ownerOf(uint64)address": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_uri(uint64)string": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_Image(uint64)string": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_totalSupply()uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_getApproved(uint64)address": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_isApprovedForAll(address,address)bool": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_balaceOf(address)uint64": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_getAllTokenNftIds(address)uint64[]": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_getTokenDetails(uint64)(address,string,string,address)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_approve(address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_setApprovalForAll(address,bool)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_upgradeUri(string,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "nft_trasferFrom(address,address,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "mint(string,string,address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "registerCompany(address)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "createParcel(string,string,string,string,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "updateParcel(uint64,string,string,uint64)void": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getParcelDetails(uint64)(string,string,uint64)": {
      "call_config": {
        "no_op": "CALL"
      }
    },
    "getAppCreatorAddress()address": {
      "call_config": {
        "no_op": "CALL"
      }
    }
  },
  "bare_call_config": {
    "no_op": "NEVER",
    "opt_in": "NEVER",
    "close_out": "NEVER",
    "update_application": "NEVER",
    "delete_application": "NEVER"
  },
  "schema": {
    "local": {
      "declared": {},
      "reserved": {}
    },
    "global": {
      "declared": {
        "counter": {
          "type": "uint64",
          "key": "counter"
        },
        "name": {
          "type": "bytes",
          "key": "name"
        },
        "symbol": {
          "type": "bytes",
          "key": "symbol"
        }
      },
      "reserved": {}
    }
  },
  "state": {
    "global": {
      "num_byte_slices": 2,
      "num_uints": 1
    },
    "local": {
      "num_byte_slices": 0,
      "num_uints": 0
    }
  },
  "source": {
    "approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjEwMy4wCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gVGhpcyBjb250cmFjdCBpcyBjb21wbGlhbnQgd2l0aCBhbmQvb3IgaW1wbGVtZW50cyB0aGUgZm9sbG93aW5nIEFSQ3M6IFsgQVJDNCBdCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKmNyZWF0ZV9Ob09wICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRAoKKk5PVF9JTVBMRU1FTlRFRDoKCS8vIFRoZSByZXF1ZXN0ZWQgYWN0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIGNvbnRyYWN0LiBBcmUgeW91IHVzaW5nIHRoZSBjb3JyZWN0IE9uQ29tcGxldGU/IERpZCB5b3Ugc2V0IHlvdXIgYXBwIElEPwoJZXJyCgovLyBjcmVhdGVBcHBsaWNhdGlvbihzdHJpbmcsc3RyaW5nKXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbjoKCS8vIF9zeW1ib2w6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBfbmFtZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgY3JlYXRlQXBwbGljYXRpb24oc3RyaW5nLHN0cmluZyl2b2lkCgljYWxsc3ViIGNyZWF0ZUFwcGxpY2F0aW9uCglpbnQgMQoJcmV0dXJuCgovLyBjcmVhdGVBcHBsaWNhdGlvbihfbmFtZTpzdHJpbmcsIF9zeW1ib2w6c3RyaW5nKTogdm9pZApjcmVhdGVBcHBsaWNhdGlvbjoKCXByb3RvIDIgMAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTUKCS8vIHRoaXMubmFtZS52YWx1ZSA9IF9uYW1lCglieXRlIDB4NmU2MTZkNjUgLy8gIm5hbWUiCglmcmFtZV9kaWcgLTEgLy8gX25hbWU6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWFwcF9nbG9iYWxfcHV0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNgoJLy8gdGhpcy5zeW1ib2wudmFsdWUgPSBfc3ltYm9sCglieXRlIDB4NzM3OTZkNjI2ZjZjIC8vICJzeW1ib2wiCglmcmFtZV9kaWcgLTIgLy8gX3N5bWJvbDogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gdXBkYXRlVHJhbnNmZXIoX2Zyb206QWRkcmVzcywgX3RvOkFkZHJlc3MsIF90b2tlbklkOnVpbnQ2NCk6IHZvaWQKdXBkYXRlVHJhbnNmZXI6Cglwcm90byAzIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAyCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoyMAoJLy8gaW5kZXg6dWludDY0ID0gMAoJaW50IDAKCWZyYW1lX2J1cnkgMCAvLyBpbmRleDogdWludDY0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoyMQoJLy8gaTp1aW50NjQgPTAKCWludCAwCglmcmFtZV9idXJ5IDEgLy8gaTogdWludDY0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoyMgoJLy8gbGVuID0gdGhpcy5vd25lckJveChfZnJvbSkudmFsdWUubGVuZ3RoCglmcmFtZV9kaWcgLTEgLy8gX2Zyb206IEFkZHJlc3MKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMub3duZXJCb3goX2Zyb20pLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglsZW4KCWludCA4CgkvCglmcmFtZV9idXJ5IDIgLy8gbGVuOiB1aW50NjQKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjI0CgkvLyBmb3IoaTtpPGxlbjtpPWkrMSkKCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoKKmZvcl8wOgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoyNAoJLy8gaTxsZW4KCWZyYW1lX2RpZyAxIC8vIGk6IHVpbnQ2NAoJZnJhbWVfZGlnIDIgLy8gbGVuOiB1aW50NjQKCTwKCWJ6ICpmb3JfMF9lbmQKCgkvLyAqaWYwX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoyNQoJLy8gdGhpcy5vd25lckJveChfZnJvbSkudmFsdWVbaV09PT1fdG9rZW5JZAoJZnJhbWVfZGlnIC0xIC8vIF9mcm9tOiBBZGRyZXNzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLm93bmVyQm94KF9mcm9tKS52YWx1ZQoJYXNzZXJ0CglleHRyYWN0IDIgMAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAwIC8vIGluaXRpYWwgb2Zmc2V0CglmcmFtZV9kaWcgMSAvLyBpOiB1aW50NjQKCWludCA4CgkqIC8vIGFjYyAqIHR5cGVMZW5ndGgKCSsKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXN3YXAKCWludCA4CglleHRyYWN0MwoJYnRvaQoJZnJhbWVfZGlnIC0zIC8vIF90b2tlbklkOiB1aW50NjQKCT09CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoyNgoJLy8gaW5kZXggPTEKCWludCAxCglmcmFtZV9idXJ5IDAgLy8gaW5kZXg6IHVpbnQ2NAoKKmlmMF9lbmQ6CgoqZm9yXzBfY29udGludWU6CgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjI0CgkvLyBpPWkrMQoJZnJhbWVfZGlnIDEgLy8gaTogdWludDY0CglpbnQgMQoJKwoJZnJhbWVfYnVyeSAxIC8vIGk6IHVpbnQ2NAoJYiAqZm9yXzAKCipmb3JfMF9lbmQ6CgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjI5CgkvLyB0aGlzLm93bmVyQm94KF9mcm9tKS52YWx1ZS5zcGxpY2UoaW5kZXgsMSkKCWZyYW1lX2RpZyAtMSAvLyBfZnJvbTogQWRkcmVzcwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5vd25lckJveChfZnJvbSkudmFsdWUKCWFzc2VydAoJZXh0cmFjdCAyIDAKCWludCAxCglmcmFtZV9kaWcgMCAvLyBpbmRleDogdWludDY0CglpbnQgOAoJKgoJc3RvcmUgMjQ3IC8vIHNwbGljZSBzdGFydAoJaW50IDE2CglzdG9yZSAyNDYgLy8gc3BsaWNlIGJ5dGUgbGVuZ3RoCglmcmFtZV9kaWcgLTEgLy8gX2Zyb206IEFkZHJlc3MKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMub3duZXJCb3goX2Zyb20pLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglpbnQgMAoJbG9hZCAyNDcgLy8gc3BsaWNlIHN0YXJ0CglzdWJzdHJpbmczCglmcmFtZV9kaWcgLTEgLy8gX2Zyb206IEFkZHJlc3MKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMub3duZXJCb3goX2Zyb20pLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglkdXAKCWxlbgoJbG9hZCAyNDcgLy8gc3BsaWNlIHN0YXJ0Cglsb2FkIDI0NiAvLyBzcGxpY2UgYnl0ZSBsZW5ndGgKCSsKCWludCA4CgktCglzd2FwCglzdWJzdHJpbmczCgljb25jYXQKCWZyYW1lX2RpZyAtMSAvLyBfZnJvbTogQWRkcmVzcwoJZHVwCglib3hfZGVsCglwb3AKCXN3YXAKCWR1cAoJbGVuCglpbnQgOAoJLwoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJYm94X3B1dAoKCS8vICppZjFfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjMwCgkvLyB0aGlzLm93bmVyQm94KF90bykuZXhpc3RzCglmcmFtZV9kaWcgLTIgLy8gX3RvOiBBZGRyZXNzCglib3hfbGVuCglzd2FwCglwb3AKCWJ6ICppZjFfZWxzZQoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czozMQoJLy8gdGhpcy5vd25lckJveChfdG8pLnZhbHVlLnB1c2goX3Rva2VuSWQpCglmcmFtZV9kaWcgLTIgLy8gX3RvOiBBZGRyZXNzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLm93bmVyQm94KF90bykudmFsdWUKCWFzc2VydAoJZXh0cmFjdCAyIDAKCWZyYW1lX2RpZyAtMyAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCgljb25jYXQKCWZyYW1lX2RpZyAtMiAvLyBfdG86IEFkZHJlc3MKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglkdXAKCWxlbgoJaW50IDgKCS8KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWJveF9wdXQKCWIgKmlmMV9lbmQKCippZjFfZWxzZToKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MzMKCS8vIHRoaXMub3duZXJCb3goX3RvKS52YWx1ZSA9IFtfdG9rZW5JZF0KCWZyYW1lX2RpZyAtMiAvLyBfdG86IEFkZHJlc3MKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgLTMgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgoqaWYxX2VuZDoKCXJldHN1YgoKLy8gdHJhbnNmZXJUbyhfdG86QWRkcmVzcywgX3Rva2VuSWQ6dWludDY0KTogdm9pZAp0cmFuc2ZlclRvOgoJcHJvdG8gMiAwCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czozOAoJLy8gYXNzZXJ0KHRoaXMudG9rZW5zKF90b2tlbklkKS5leGlzdHMpCglmcmFtZV9kaWcgLTIgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjM5CgkvLyB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUub3duZXIgPSBfdG8KCWZyYW1lX2RpZyAtMiAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAwCglmcmFtZV9kaWcgLTEgLy8gX3RvOiBBZGRyZXNzCglyZXBsYWNlMwoJZnJhbWVfZGlnIC0yIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo0MAoJLy8gdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlLmNvbnRyb2wgPSBnbG9iYWxzLnplcm9BZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMzYKCWdsb2JhbCBaZXJvQWRkcmVzcwoJcmVwbGFjZTMKCWZyYW1lX2RpZyAtMiAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJcmV0c3ViCgovLyBuZnRfb3duZXJPZih1aW50NjQpYWRkcmVzcwoqYWJpX3JvdXRlX25mdF9vd25lck9mOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBfdG9rZW5JZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBuZnRfb3duZXJPZih1aW50NjQpYWRkcmVzcwoJY2FsbHN1YiBuZnRfb3duZXJPZgoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIG5mdF9vd25lck9mKF90b2tlbklkOnVpbnQ2NCk6IEFkZHJlc3MKbmZ0X293bmVyT2Y6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjQ0CgkvLyBhc3NlcnQodGhpcy50b2tlbnMoX3Rva2VuSWQpLmV4aXN0cykKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NDUKCS8vIHJldHVybiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUub3duZXI7CglmcmFtZV9kaWcgLTEgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDAgMzIKCXJldHN1YgoKLy8gbmZ0X3VyaSh1aW50NjQpc3RyaW5nCiphYmlfcm91dGVfbmZ0X3VyaToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJYnRvaQoKCS8vIGV4ZWN1dGUgbmZ0X3VyaSh1aW50NjQpc3RyaW5nCgljYWxsc3ViIG5mdF91cmkKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gbmZ0X3VyaShfdG9rZW5JZDp1aW50NjQpOiBzdHJpbmcKbmZ0X3VyaToKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NDkKCS8vIGFzc2VydCh0aGlzLnRva2VucyhfdG9rZW5JZCkuZXhpc3RzKQoJZnJhbWVfZGlnIC0xIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo1MAoJLy8gcmV0dXJuIHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZS50b2tlblVyaTsKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAzMgoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJZHVwIC8vIGR1cGxpY2F0ZSBzdGFydCBvZiBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglleHRyYWN0X3VpbnQxNiAvLyBnZXQgbnVtYmVyIG9mIGVsZW1lbnRzCglpbnQgMSAvLyBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludCAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJZXh0cmFjdDMKCWV4dHJhY3QgMiAwCglyZXRzdWIKCi8vIG5mdF9JbWFnZSh1aW50NjQpc3RyaW5nCiphYmlfcm91dGVfbmZ0X0ltYWdlOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBfdG9rZW5JZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSBuZnRfSW1hZ2UodWludDY0KXN0cmluZwoJY2FsbHN1YiBuZnRfSW1hZ2UKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gbmZ0X0ltYWdlKF90b2tlbklkOnVpbnQ2NCk6IHN0cmluZwpuZnRfSW1hZ2U6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjU0CgkvLyBhc3NlcnQodGhpcy50b2tlbnMoX3Rva2VuSWQpLmV4aXN0cykKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NTUKCS8vIHJldHVybiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUuaW1hZ2U7CglmcmFtZV9kaWcgLTEgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMzQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXVuY292ZXIgMgoJZXh0cmFjdF91aW50MTYKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50IDEgLy8gZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnQgMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCWV4dHJhY3QzCglleHRyYWN0IDIgMAoJcmV0c3ViCgovLyBuZnRfdG90YWxTdXBwbHkoKXVpbnQ2NAoqYWJpX3JvdXRlX25mdF90b3RhbFN1cHBseToKCS8vIFRoZSBBQkkgcmV0dXJuIHByZWZpeAoJYnl0ZSAweDE1MWY3Yzc1CgoJLy8gZXhlY3V0ZSBuZnRfdG90YWxTdXBwbHkoKXVpbnQ2NAoJY2FsbHN1YiBuZnRfdG90YWxTdXBwbHkKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBuZnRfdG90YWxTdXBwbHkoKTogdWludDY0Cm5mdF90b3RhbFN1cHBseToKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NTkKCS8vIHJldHVybiB0aGlzLmNvdW50ZXIudmFsdWU7CglieXRlIDB4NjM2Zjc1NmU3NDY1NzIgLy8gImNvdW50ZXIiCglhcHBfZ2xvYmFsX2dldAoJcmV0c3ViCgovLyBuZnRfZ2V0QXBwcm92ZWQodWludDY0KWFkZHJlc3MKKmFiaV9yb3V0ZV9uZnRfZ2V0QXBwcm92ZWQ6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIF90b2tlbklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIG5mdF9nZXRBcHByb3ZlZCh1aW50NjQpYWRkcmVzcwoJY2FsbHN1YiBuZnRfZ2V0QXBwcm92ZWQKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBuZnRfZ2V0QXBwcm92ZWQoX3Rva2VuSWQ6dWludDY0KTogQWRkcmVzcwpuZnRfZ2V0QXBwcm92ZWQ6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjYzCgkvLyByZXR1cm4gdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlLmNvbnRyb2w7CglmcmFtZV9kaWcgLTEgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglleHRyYWN0IDM2IDMyCglyZXRzdWIKCi8vIG5mdF9pc0FwcHJvdmVkRm9yQWxsKGFkZHJlc3MsYWRkcmVzcylib29sCiphYmlfcm91dGVfbmZ0X2lzQXBwcm92ZWRGb3JBbGw6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIF9vcGVyYXRvcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChfb3BlcmF0b3IpIGZvciBuZnRfaXNBcHByb3ZlZEZvckFsbCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gX293bmVyOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKF9vd25lcikgZm9yIG5mdF9pc0FwcHJvdmVkRm9yQWxsIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIG5mdF9pc0FwcHJvdmVkRm9yQWxsKGFkZHJlc3MsYWRkcmVzcylib29sCgljYWxsc3ViIG5mdF9pc0FwcHJvdmVkRm9yQWxsCglieXRlIDB4MDAKCWludCAwCgl1bmNvdmVyIDIKCXNldGJpdAoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIG5mdF9pc0FwcHJvdmVkRm9yQWxsKF9vd25lcjpBZGRyZXNzLCBfb3BlcmF0b3I6QWRkcmVzcyk6IGJvb2xlYW4KbmZ0X2lzQXBwcm92ZWRGb3JBbGw6Cglwcm90byAyIDEKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NjcKCS8vIGNvbnRyb2wgOiBTdGF0aWNBcnJheTxBZGRyZXNzLDI+ID0gW19vd25lcixfb3BlcmF0b3JdCglmcmFtZV9kaWcgLTEgLy8gX293bmVyOiBBZGRyZXNzCglmcmFtZV9kaWcgLTIgLy8gX29wZXJhdG9yOiBBZGRyZXNzCgljb25jYXQKCWZyYW1lX2J1cnkgMCAvLyBjb250cm9sOiBTdGF0aWNBcnJheTxBZGRyZXNzLDI+CgoJLy8gKmlmMl9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NjgKCS8vIHRoaXMuYXBwcm92YWxBbGwoY29udHJvbCkuZXhpc3RzCglmcmFtZV9kaWcgMCAvLyBjb250cm9sOiBTdGF0aWNBcnJheTxBZGRyZXNzLDI+Cglib3hfbGVuCglzd2FwCglwb3AKCWJ6ICppZjJfZW5kCgoJLy8gKmlmMl9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjY4CgkvLyByZXR1cm4gdHJ1ZTsKCWludCAxCgliICpuZnRfaXNBcHByb3ZlZEZvckFsbCpyZXR1cm4KCippZjJfZW5kOgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo2OQoJLy8gcmV0dXJuIGZhbHNlOwoJaW50IDAKCipuZnRfaXNBcHByb3ZlZEZvckFsbCpyZXR1cm46CgkvLyBzZXQgdGhlIHN1YnJvdXRpbmUgcmV0dXJuIHZhbHVlCglmcmFtZV9idXJ5IDAKCXJldHN1YgoKLy8gbmZ0X2JhbGFjZU9mKGFkZHJlc3MpdWludDY0CiphYmlfcm91dGVfbmZ0X2JhbGFjZU9mOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBfb3duZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoX293bmVyKSBmb3IgbmZ0X2JhbGFjZU9mIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIG5mdF9iYWxhY2VPZihhZGRyZXNzKXVpbnQ2NAoJY2FsbHN1YiBuZnRfYmFsYWNlT2YKCWl0b2IKCWNvbmNhdAoJbG9nCglpbnQgMQoJcmV0dXJuCgovLyBuZnRfYmFsYWNlT2YoX293bmVyOkFkZHJlc3MpOiB1aW50NjQKbmZ0X2JhbGFjZU9mOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo3MwoJLy8gYXNzZXJ0KHRoaXMub3duZXJCb3goX293bmVyKS5leGlzdHMpCglmcmFtZV9kaWcgLTEgLy8gX293bmVyOiBBZGRyZXNzCglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NzQKCS8vIHJldHVybiB0aGlzLm93bmVyQm94KF9vd25lcikudmFsdWUubGVuZ3RoOwoJZnJhbWVfZGlnIC0xIC8vIF9vd25lcjogQWRkcmVzcwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5vd25lckJveChfb3duZXIpLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglsZW4KCWludCA4CgkvCglyZXRzdWIKCi8vIG5mdF9nZXRBbGxUb2tlbk5mdElkcyhhZGRyZXNzKXVpbnQ2NFtdCiphYmlfcm91dGVfbmZ0X2dldEFsbFRva2VuTmZ0SWRzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBfb3duZXI6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09CgoJLy8gYXJndW1lbnQgMCAoX293bmVyKSBmb3IgbmZ0X2dldEFsbFRva2VuTmZ0SWRzIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIG5mdF9nZXRBbGxUb2tlbk5mdElkcyhhZGRyZXNzKXVpbnQ2NFtdCgljYWxsc3ViIG5mdF9nZXRBbGxUb2tlbk5mdElkcwoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gbmZ0X2dldEFsbFRva2VuTmZ0SWRzKF9vd25lcjpBZGRyZXNzKTogdWludDY0W10KbmZ0X2dldEFsbFRva2VuTmZ0SWRzOgoJcHJvdG8gMSAxCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo3OAoJLy8gYXNzZXJ0KHRoaXMub3duZXJCb3goX293bmVyKS5leGlzdHMpCglmcmFtZV9kaWcgLTEgLy8gX293bmVyOiBBZGRyZXNzCglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6NzkKCS8vIHJldHVybiB0aGlzLm93bmVyQm94KF9vd25lcikudmFsdWU7CglmcmFtZV9kaWcgLTEgLy8gX293bmVyOiBBZGRyZXNzCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLm93bmVyQm94KF9vd25lcikudmFsdWUKCWFzc2VydAoJZXh0cmFjdCAyIDAKCXJldHN1YgoKLy8gbmZ0X2dldFRva2VuRGV0YWlscyh1aW50NjQpKGFkZHJlc3Msc3RyaW5nLHN0cmluZyxhZGRyZXNzKQoqYWJpX3JvdXRlX25mdF9nZXRUb2tlbkRldGFpbHM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIF90b2tlbklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIG5mdF9nZXRUb2tlbkRldGFpbHModWludDY0KShhZGRyZXNzLHN0cmluZyxzdHJpbmcsYWRkcmVzcykKCWNhbGxzdWIgbmZ0X2dldFRva2VuRGV0YWlscwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIG5mdF9nZXRUb2tlbkRldGFpbHMoX3Rva2VuSWQ6dWludDY0KTogdG9rZW4KbmZ0X2dldFRva2VuRGV0YWlsczoKCXByb3RvIDEgMQoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6ODMKCS8vIGFzc2VydCh0aGlzLnRva2VucyhfdG9rZW5JZCkuZXhpc3RzKQoJZnJhbWVfZGlnIC0xIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo4NAoJLy8gcmV0dXJuIHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZTsKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJcmV0c3ViCgovLyBuZnRfYXBwcm92ZShhZGRyZXNzLHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfbmZ0X2FwcHJvdmU6CgkvLyBfdG9rZW5JZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gX2FwcHJvdmVkOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKF9hcHByb3ZlZCkgZm9yIG5mdF9hcHByb3ZlIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIG5mdF9hcHByb3ZlKGFkZHJlc3MsdWludDY0KXZvaWQKCWNhbGxzdWIgbmZ0X2FwcHJvdmUKCWludCAxCglyZXR1cm4KCi8vIG5mdF9hcHByb3ZlKF9hcHByb3ZlZDpBZGRyZXNzLCBfdG9rZW5JZDp1aW50NjQpOiB2b2lkCm5mdF9hcHByb3ZlOgoJcHJvdG8gMiAwCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo4OAoJLy8gYXNzZXJ0KHRoaXMudG9rZW5zKF90b2tlbklkKS5leGlzdHMpCglmcmFtZV9kaWcgLTIgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2xlbgoJc3dhcAoJcG9wCglhc3NlcnQKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjg5CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyPT09dGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlLm93bmVyKQoJdHhuIFNlbmRlcgoJZnJhbWVfZGlnIC0yIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDMyCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo5MQoJLy8gdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlLmNvbnRyb2wgPSBfYXBwcm92ZWQKCWZyYW1lX2RpZyAtMiAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAzNgoJZnJhbWVfZGlnIC0xIC8vIF9hcHByb3ZlZDogQWRkcmVzcwoJcmVwbGFjZTMKCWZyYW1lX2RpZyAtMiAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJcmV0c3ViCgovLyBuZnRfc2V0QXBwcm92YWxGb3JBbGwoYWRkcmVzcyxib29sKXZvaWQKKmFiaV9yb3V0ZV9uZnRfc2V0QXBwcm92YWxGb3JBbGw6CgkvLyBfYXBwcm92ZWQ6IGJvb2wKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWR1cAoJbGVuCglpbnQgMQoJPT0KCgkvLyBhcmd1bWVudCAwIChfYXBwcm92ZWQpIGZvciBuZnRfc2V0QXBwcm92YWxGb3JBbGwgbXVzdCBiZSBhIGJvb2wKCWFzc2VydAoJaW50IDAKCWdldGJpdAoKCS8vIF9vcGVyYXRvcjogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChfb3BlcmF0b3IpIGZvciBuZnRfc2V0QXBwcm92YWxGb3JBbGwgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgbmZ0X3NldEFwcHJvdmFsRm9yQWxsKGFkZHJlc3MsYm9vbCl2b2lkCgljYWxsc3ViIG5mdF9zZXRBcHByb3ZhbEZvckFsbAoJaW50IDEKCXJldHVybgoKLy8gbmZ0X3NldEFwcHJvdmFsRm9yQWxsKF9vcGVyYXRvcjpBZGRyZXNzLCBfYXBwcm92ZWQ6Ym9vbGVhbik6IHZvaWQKbmZ0X3NldEFwcHJvdmFsRm9yQWxsOgoJcHJvdG8gMiAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjk1CgkvLyBjb250cm9sOlN0YXRpY0FycmF5PEFkZHJlc3MsMj4gPSBbdGhpcy50eG4uc2VuZGVyLF9vcGVyYXRvcl0KCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMSAvLyBfb3BlcmF0b3I6IEFkZHJlc3MKCWNvbmNhdAoJZnJhbWVfYnVyeSAwIC8vIGNvbnRyb2w6IFN0YXRpY0FycmF5PEFkZHJlc3MsMj4KCgkvLyAqaWYzX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo5NwoJLy8gX2FwcHJvdmVkCglmcmFtZV9kaWcgLTIgLy8gX2FwcHJvdmVkOiBib29sZWFuCglieiAqaWYzX2Vsc2UKCgkvLyAqaWYzX2NvbnNlcXVlbnQKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6OTcKCS8vIHRoaXMuYXBwcm92YWxBbGwoY29udHJvbCkudmFsdWUgPSIiCglmcmFtZV9kaWcgMCAvLyBjb250cm9sOiBTdGF0aWNBcnJheTxBZGRyZXNzLDI+CglkdXAKCWJveF9kZWwKCXBvcAoJYnl0ZSAweCAvLyAiIgoJYm94X3B1dAoJYiAqaWYzX2VuZAoKKmlmM19lbHNlOgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czo5OAoJLy8gdGhpcy5hcHByb3ZhbEFsbChjb250cm9sKS5kZWxldGUoKQoJZnJhbWVfZGlnIDAgLy8gY29udHJvbDogU3RhdGljQXJyYXk8QWRkcmVzcywyPgoJYm94X2RlbAoKKmlmM19lbmQ6CglyZXRzdWIKCi8vIG5mdF91cGdyYWRlVXJpKHN0cmluZyx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX25mdF91cGdyYWRlVXJpOgoJLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIF90b2tlblVyaTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgbmZ0X3VwZ3JhZGVVcmkoc3RyaW5nLHVpbnQ2NCl2b2lkCgljYWxsc3ViIG5mdF91cGdyYWRlVXJpCglpbnQgMQoJcmV0dXJuCgovLyBuZnRfdXBncmFkZVVyaShfdG9rZW5Vcmk6c3RyaW5nLCBfdG9rZW5JZDp1aW50NjQpOiB2b2lkCm5mdF91cGdyYWRlVXJpOgoJcHJvdG8gMiAwCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMDIKCS8vIGFzc2VydCh0aGlzLnRva2VucyhfdG9rZW5JZCkuZXhpc3RzKQoJZnJhbWVfZGlnIC0yIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMDMKCS8vIHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZS50b2tlblVyaT1fdG9rZW5VcmkKCWZyYW1lX2RpZyAtMiAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCAzMgoJZHVwCglzdG9yZSAyNTEgLy8gZWxlbWVudCBoZWFkIG9mZnNldAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJZHVwCglzdG9yZSAyNTQgLy8gZWxlbWVudCBzdGFydAoJZHVwIC8vIGR1cGxpY2F0ZSBzdGFydCBvZiBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglleHRyYWN0X3VpbnQxNiAvLyBnZXQgbnVtYmVyIG9mIGVsZW1lbnRzCglpbnQgMSAvLyBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludCAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJc3RvcmUgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMAoJbG9hZCAyNTQgLy8gZWxlbWVudCBzdGFydAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIC0xIC8vIF90b2tlblVyaTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJZHVwCglzdG9yZSAyNTIgLy8gbmV3IGVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU0IC8vIGVsZW1lbnQgc3RhcnQKCWxvYWQgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCgkrIC8vIGdldCBlbmQgb2YgRWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbGVuCglzdWJzdHJpbmczCgljb25jYXQKCWNvbmNhdAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWNhbGxzdWIgKmdldF9sZW5ndGhfZGlmZmVyZW5jZQoJbG9hZCAyNTAgLy8gbGVuZ3RoIGRpZmZlcmVuY2UKCWxvYWQgMjUxIC8vIGVsZW1lbnQgaGVhZCBvZmZzZXQKCWludCAyCgkrIC8vIGhlYWQgb2ZzZXQKCWNhbGxzdWIgKnVwZGF0ZV9keW5hbWljX2hlYWQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWZyYW1lX2RpZyAtMiAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoJcmV0c3ViCgovLyBuZnRfdHJhc2ZlckZyb20oYWRkcmVzcyxhZGRyZXNzLHVpbnQ2NCl2b2lkCiphYmlfcm91dGVfbmZ0X3RyYXNmZXJGcm9tOgoJLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwoJYnRvaQoKCS8vIF90bzogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAxIChfdG8pIGZvciBuZnRfdHJhc2ZlckZyb20gbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIF9mcm9tOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDIgKF9mcm9tKSBmb3IgbmZ0X3RyYXNmZXJGcm9tIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIG5mdF90cmFzZmVyRnJvbShhZGRyZXNzLGFkZHJlc3MsdWludDY0KXZvaWQKCWNhbGxzdWIgbmZ0X3RyYXNmZXJGcm9tCglpbnQgMQoJcmV0dXJuCgovLyBuZnRfdHJhc2ZlckZyb20oX2Zyb206QWRkcmVzcywgX3RvOkFkZHJlc3MsIF90b2tlbklkOnVpbnQ2NCk6IHZvaWQKbmZ0X3RyYXNmZXJGcm9tOgoJcHJvdG8gMyAwCgoJLy8gUHVzaCBlbXB0eSBieXRlcyBhZnRlciB0aGUgZnJhbWUgcG9pbnRlciB0byByZXNlcnZlIHNwYWNlIGZvciBsb2NhbCB2YXJpYWJsZXMKCWJ5dGUgMHgKCWR1cAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTA3CgkvLyBvd25lck5mdCA9IHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZS5vd25lcgoJZnJhbWVfZGlnIC0zIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAwIDMyCglmcmFtZV9idXJ5IDAgLy8gb3duZXJOZnQ6IGFkZHJlc3MKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjEwOAoJLy8gY29udHJvbDpTdGF0aWNBcnJheTxBZGRyZXNzLDI+ID0gW293bmVyTmZ0LHRoaXMudHhuLnNlbmRlcl0KCWZyYW1lX2RpZyAwIC8vIG93bmVyTmZ0OiBhZGRyZXNzCgl0eG4gU2VuZGVyCgljb25jYXQKCWZyYW1lX2J1cnkgMSAvLyBjb250cm9sOiBTdGF0aWNBcnJheTxBZGRyZXNzLDI+CgoJLy8gKmlmNF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTEwCgkvLyB0aGlzLnR4bi5zZW5kZXI9PT10aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUub3duZXIgfHwgdGhpcy50b2tlbnMoX3Rva2VuSWQpLnZhbHVlLmNvbnRyb2w9PT10aGlzLnR4bi5zZW5kZXIgfHwgdGhpcy5hcHByb3ZhbEFsbChjb250cm9sKS5leGlzdHMKCXR4biBTZW5kZXIKCWZyYW1lX2RpZyAtMyAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnRva2VucyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWV4dHJhY3QgMCAzMgoJPT0KCWR1cAoJYm56ICpza2lwX29yMAoJZnJhbWVfZGlnIC0zIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMudG9rZW5zKF90b2tlbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZXh0cmFjdCAzNiAzMgoJdHhuIFNlbmRlcgoJPT0KCXx8Cgoqc2tpcF9vcjA6CglkdXAKCWJueiAqc2tpcF9vcjEKCWZyYW1lX2RpZyAxIC8vIGNvbnRyb2w6IFN0YXRpY0FycmF5PEFkZHJlc3MsMj4KCWJveF9sZW4KCXN3YXAKCXBvcAoJfHwKCipza2lwX29yMToKCWJ6ICppZjRfZWxzZQoKCS8vICppZjRfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMTEKCS8vIHRoaXMudHJhbnNmZXJUbyhfdG8sX3Rva2VuSWQpCglmcmFtZV9kaWcgLTMgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJZnJhbWVfZGlnIC0yIC8vIF90bzogQWRkcmVzcwoJY2FsbHN1YiB0cmFuc2ZlclRvCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMTIKCS8vIHRoaXMudXBkYXRlVHJhbnNmZXIoX2Zyb20sX3RvLF90b2tlbklkKQoJZnJhbWVfZGlnIC0zIC8vIF90b2tlbklkOiB1aW50NjQKCWZyYW1lX2RpZyAtMiAvLyBfdG86IEFkZHJlc3MKCWZyYW1lX2RpZyAtMSAvLyBfZnJvbTogQWRkcmVzcwoJY2FsbHN1YiB1cGRhdGVUcmFuc2ZlcgoJYiAqaWY0X2VuZAoKKmlmNF9lbHNlOgoJLy8gTm90IGF1dGhvcml6ZWQKCWVycgoKKmlmNF9lbmQ6CglyZXRzdWIKCi8vIG1pbnQoc3RyaW5nLHN0cmluZyxhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9taW50OgoJLy8gX3RvOiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKF90bykgZm9yIG1pbnQgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIF90b2tlblVyaTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglleHRyYWN0IDIgMAoKCS8vIF9pbWFnZTogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglleHRyYWN0IDIgMAoKCS8vIGV4ZWN1dGUgbWludChzdHJpbmcsc3RyaW5nLGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBtaW50CglpbnQgMQoJcmV0dXJuCgovLyBtaW50KF9pbWFnZSA6c3RyaW5nLCBfdG9rZW5Vcmk6c3RyaW5nLCBfdG86QWRkcmVzcyk6IHZvaWQKbWludDoKCXByb3RvIDMgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMjAKCS8vIGFzc2VydCh0aGlzLmNvdW50ZXIudmFsdWU8MTAwMCkKCWJ5dGUgMHg2MzZmNzU2ZTc0NjU3MiAvLyAiY291bnRlciIKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMTAwMAoJPAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMjEKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXI9PT10aGlzLmFwcC5jcmVhdG9yKQoJdHhuIFNlbmRlcgoJdHhuYSBBcHBsaWNhdGlvbnMgMAoJYXBwX3BhcmFtc19nZXQgQXBwQ3JlYXRvcgoJcG9wCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMzEKCS8vIFRva2VuIDp0b2tlbiA9ewoJLy8gICAgICAgb3duZXI6X3RvLAoJLy8gICAgICAgdG9rZW5Vcmk6X3Rva2VuVXJpLAoJLy8gICAgICAgaW1hZ2U6X2ltYWdlLAoJLy8gICAgICAgY29udHJvbDpnbG9iYWxzLnplcm9BZGRyZXNzCgkvLyAgICAgfQoJYnl0ZSAweCAvLyBpbml0aWFsIGhlYWQKCWJ5dGUgMHggLy8gaW5pdGlhbCB0YWlsCglieXRlIDB4MDA0NCAvLyBpbml0aWFsIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gX3RvOiBBZGRyZXNzCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50CglmcmFtZV9kaWcgLTIgLy8gX3Rva2VuVXJpOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC0xIC8vIF9pbWFnZTogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCWdsb2JhbCBaZXJvQWRkcmVzcwoJY2FsbHN1YiAqcHJvY2Vzc19zdGF0aWNfdHVwbGVfZWxlbWVudAoJcG9wIC8vIHBvcCBoZWFkIG9mZnNldAoJY29uY2F0IC8vIGNvbmNhdCBoZWFkIGFuZCB0YWlsCglmcmFtZV9idXJ5IDAgLy8gVG9rZW46IHRva2VuCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMzgKCS8vIHRoaXMudG9rZW5zKHRoaXMuY291bnRlci52YWx1ZSkudmFsdWUgPSBUb2tlbgoJYnl0ZSAweDYzNmY3NTZlNzQ2NTcyIC8vICJjb3VudGVyIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgMCAvLyBUb2tlbjogdG9rZW4KCWJveF9wdXQKCgkvLyAqaWY1X2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxMzkKCS8vIHRoaXMub3duZXJCb3goX3RvKS5leGlzdHMKCWZyYW1lX2RpZyAtMyAvLyBfdG86IEFkZHJlc3MKCWJveF9sZW4KCXN3YXAKCXBvcAoJYnogKmlmNV9lbHNlCgoJLy8gKmlmNV9jb25zZXF1ZW50CgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjE0MAoJLy8gdGhpcy5vd25lckJveChfdG8pLnZhbHVlLnB1c2godGhpcy5jb3VudGVyLnZhbHVlKQoJZnJhbWVfZGlnIC0zIC8vIF90bzogQWRkcmVzcwoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5vd25lckJveChfdG8pLnZhbHVlCglhc3NlcnQKCWV4dHJhY3QgMiAwCglieXRlIDB4NjM2Zjc1NmU3NDY1NzIgLy8gImNvdW50ZXIiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJY29uY2F0CglmcmFtZV9kaWcgLTMgLy8gX3RvOiBBZGRyZXNzCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgliICppZjVfZW5kCgoqaWY1X2Vsc2U6CgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjE0MgoJLy8gdGhpcy5vd25lckJveChfdG8pLnZhbHVlID0gW3RoaXMuY291bnRlci52YWx1ZV0KCWZyYW1lX2RpZyAtMyAvLyBfdG86IEFkZHJlc3MKCWR1cAoJYm94X2RlbAoJcG9wCglieXRlIDB4NjM2Zjc1NmU3NDY1NzIgLy8gImNvdW50ZXIiCglhcHBfZ2xvYmFsX2dldAoJaXRvYgoJZHVwCglsZW4KCWludCA4CgkvCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0Cglib3hfcHV0CgoqaWY1X2VuZDoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTQ0CgkvLyB0aGlzLmNvdW50ZXIudmFsdWUgPSB0aGlzLmNvdW50ZXIudmFsdWUgKyAxCglieXRlIDB4NjM2Zjc1NmU3NDY1NzIgLy8gImNvdW50ZXIiCglkdXAKCWFwcF9nbG9iYWxfZ2V0CglpbnQgMQoJKwoJYXBwX2dsb2JhbF9wdXQKCXJldHN1YgoKLy8gcmVnaXN0ZXJDb21wYW55KGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX3JlZ2lzdGVyQ29tcGFueToKCS8vIF9jb21wYW55QWRkcmVzczogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAwIChfY29tcGFueUFkZHJlc3MpIGZvciByZWdpc3RlckNvbXBhbnkgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgcmVnaXN0ZXJDb21wYW55KGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiByZWdpc3RlckNvbXBhbnkKCWludCAxCglyZXR1cm4KCi8vIHJlZ2lzdGVyQ29tcGFueShfY29tcGFueUFkZHJlc3M6QWRkcmVzcyk6IHZvaWQKcmVnaXN0ZXJDb21wYW55OgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNDgKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXI9PXRoaXMuYXBwLmNyZWF0b3IpCgl0eG4gU2VuZGVyCgl0eG5hIEFwcGxpY2F0aW9ucyAwCglhcHBfcGFyYW1zX2dldCBBcHBDcmVhdG9yCglwb3AKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjE0OQoJLy8gdGhpcy5yZWdpc3RlcmVkQ29tcGFueShfY29tcGFueUFkZHJlc3MpLnZhbHVlID0gdHJ1ZQoJZnJhbWVfZGlnIC0xIC8vIF9jb21wYW55QWRkcmVzczogQWRkcmVzcwoJaW50IDEKCWJ5dGUgMHgwMAoJaW50IDAKCXVuY292ZXIgMgoJc2V0Yml0Cglib3hfcHV0CglyZXRzdWIKCi8vIGNyZWF0ZVBhcmNlbChzdHJpbmcsc3RyaW5nLHN0cmluZyxzdHJpbmcsdWludDY0KXZvaWQKKmFiaV9yb3V0ZV9jcmVhdGVQYXJjZWw6CgkvLyBfbGFzdFVwZGF0ZWQ6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNQoJYnRvaQoKCS8vIF9zdGF0dXM6IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgNAoJZXh0cmFjdCAyIDAKCgkvLyBfaW5pdGlhbExvY2F0aW9uOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWV4dHJhY3QgMiAwCgoJLy8gX3Rva2VuVXJpOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDIKCWV4dHJhY3QgMiAwCgoJLy8gX2ltYWdlOiBzdHJpbmcKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWV4dHJhY3QgMiAwCgoJLy8gZXhlY3V0ZSBjcmVhdGVQYXJjZWwoc3RyaW5nLHN0cmluZyxzdHJpbmcsc3RyaW5nLHVpbnQ2NCl2b2lkCgljYWxsc3ViIGNyZWF0ZVBhcmNlbAoJaW50IDEKCXJldHVybgoKLy8gY3JlYXRlUGFyY2VsKF9pbWFnZSA6c3RyaW5nLCBfdG9rZW5Vcmk6c3RyaW5nLCBfaW5pdGlhbExvY2F0aW9uOnN0cmluZywgX3N0YXR1czpzdHJpbmcsIF9sYXN0VXBkYXRlZDp1aW50NjQpOiB2b2lkCmNyZWF0ZVBhcmNlbDoKCXByb3RvIDUgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNTMKCS8vIGFzc2VydCh0aGlzLnJlZ2lzdGVyZWRDb21wYW55KHRoaXMudHhuLnNlbmRlcikudmFsdWU9PT10cnVlKQoJdHhuIFNlbmRlcgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5yZWdpc3RlcmVkQ29tcGFueSh0aGlzLnR4bi5zZW5kZXIpLnZhbHVlCglhc3NlcnQKCWludCAwCglnZXRiaXQKCWludCAxCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNTQKCS8vIHBhcmNlbCA6IHBhcmNlbFN0YXR1cyA9IHtjdXJyZW50TG9jYXRpb246IF9pbml0aWFsTG9jYXRpb24sc3RhdHVzOl9zdGF0dXMsbGFzdFVwZGF0ZWQ6X2xhc3RVcGRhdGVkfQoJYnl0ZSAweCAvLyBpbml0aWFsIGhlYWQKCWJ5dGUgMHggLy8gaW5pdGlhbCB0YWlsCglieXRlIDB4MDAwYyAvLyBpbml0aWFsIGhlYWQgb2Zmc2V0CglmcmFtZV9kaWcgLTMgLy8gX2luaXRpYWxMb2NhdGlvbjogc3RyaW5nCglkdXAKCWxlbgoJaXRvYgoJZXh0cmFjdCA2IDIKCXN3YXAKCWNvbmNhdAoJY2FsbHN1YiAqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQKCWZyYW1lX2RpZyAtNCAvLyBfc3RhdHVzOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CgljYWxsc3ViICpwcm9jZXNzX2R5bmFtaWNfdHVwbGVfZWxlbWVudAoJZnJhbWVfZGlnIC01IC8vIF9sYXN0VXBkYXRlZDogdWludDY0CglpdG9iCgljYWxsc3ViICpwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50Cglwb3AgLy8gcG9wIGhlYWQgb2Zmc2V0Cgljb25jYXQgLy8gY29uY2F0IGhlYWQgYW5kIHRhaWwKCWZyYW1lX2J1cnkgMCAvLyBwYXJjZWw6IHBhcmNlbFN0YXR1cwoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTU1CgkvLyB0aGlzLnBhcmNlbERlYXRpbHModGhpcy5jb3VudGVyLnZhbHVlKS52YWx1ZSA9IHBhcmNlbAoJYnl0ZSAweDYzNmY3NTZlNzQ2NTcyIC8vICJjb3VudGVyIgoJYXBwX2dsb2JhbF9nZXQKCWl0b2IKCWR1cAoJYm94X2RlbAoJcG9wCglmcmFtZV9kaWcgMCAvLyBwYXJjZWw6IHBhcmNlbFN0YXR1cwoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTU2CgkvLyB0aGlzLm1pbnQoX2ltYWdlLF90b2tlblVyaSx0aGlzLnR4bi5zZW5kZXIpCgl0eG4gU2VuZGVyCglmcmFtZV9kaWcgLTIgLy8gX3Rva2VuVXJpOiBzdHJpbmcKCWZyYW1lX2RpZyAtMSAvLyBfaW1hZ2U6IHN0cmluZwoJY2FsbHN1YiBtaW50CglyZXRzdWIKCi8vIHVwZGF0ZVBhcmNlbCh1aW50NjQsc3RyaW5nLHN0cmluZyx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX3VwZGF0ZVBhcmNlbDoKCS8vIF9sYXN0VXBkYXRlZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyA0CglidG9pCgoJLy8gX3N0YXR1czogc3RyaW5nCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglleHRyYWN0IDIgMAoKCS8vIF9jdXJyZW50TG9jYXRpb246IHN0cmluZwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJZXh0cmFjdCAyIDAKCgkvLyBfdG9rZW5JZDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglidG9pCgoJLy8gZXhlY3V0ZSB1cGRhdGVQYXJjZWwodWludDY0LHN0cmluZyxzdHJpbmcsdWludDY0KXZvaWQKCWNhbGxzdWIgdXBkYXRlUGFyY2VsCglpbnQgMQoJcmV0dXJuCgovLyB1cGRhdGVQYXJjZWwoX3Rva2VuSWQ6dWludDY0LCBfY3VycmVudExvY2F0aW9uOnN0cmluZywgX3N0YXR1czpzdHJpbmcsIF9sYXN0VXBkYXRlZDp1aW50NjQpOiB2b2lkCnVwZGF0ZVBhcmNlbDoKCXByb3RvIDQgMAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTYwCgkvLyBhc3NlcnQodGhpcy5yZWdpc3RlcmVkQ29tcGFueSh0aGlzLnR4bi5zZW5kZXIpLmV4aXN0cykKCXR4biBTZW5kZXIKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNjEKCS8vIGFzc2VydCh0aGlzLnBhcmNlbERlYXRpbHMoX3Rva2VuSWQpLmV4aXN0cykKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfbGVuCglzd2FwCglwb3AKCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTYyCgkvLyB0aGlzLnBhcmNlbERlYXRpbHMoX3Rva2VuSWQpLnZhbHVlLmN1cnJlbnRMb2NhdGlvbj1fY3VycmVudExvY2F0aW9uCglmcmFtZV9kaWcgLTEgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJYm94X2dldAoKCS8vIGJveCB2YWx1ZSBkb2VzIG5vdCBleGlzdDogdGhpcy5wYXJjZWxEZWF0aWxzKF90b2tlbklkKS52YWx1ZQoJYXNzZXJ0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJaW50IDAKCWR1cAoJc3RvcmUgMjUxIC8vIGVsZW1lbnQgaGVhZCBvZmZzZXQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCXVuY292ZXIgMgoJZXh0cmFjdF91aW50MTYKCWR1cAoJc3RvcmUgMjU0IC8vIGVsZW1lbnQgc3RhcnQKCWR1cCAvLyBkdXBsaWNhdGUgc3RhcnQgb2YgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJc3dhcAoJZXh0cmFjdF91aW50MTYgLy8gZ2V0IG51bWJlciBvZiBlbGVtZW50cwoJaW50IDEgLy8gZ2V0IHR5cGUgbGVuZ3RoCgkqIC8vIG11bHRpcGx5IGJ5IHR5cGUgbGVuZ3RoCglpbnQgMgoJKyAvLyBhZGQgdHdvIGZvciBsZW5ndGgKCXN0b3JlIDI1MyAvLyBlbGVtZW50IGxlbmd0aAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJaW50IDAKCWxvYWQgMjU0IC8vIGVsZW1lbnQgc3RhcnQKCXN1YnN0cmluZzMKCWZyYW1lX2RpZyAtMiAvLyBfY3VycmVudExvY2F0aW9uOiBzdHJpbmcKCWR1cAoJbGVuCglpdG9iCglleHRyYWN0IDYgMgoJc3dhcAoJY29uY2F0CglkdXAKCXN0b3JlIDI1MiAvLyBuZXcgZWxlbWVudAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTQgLy8gZWxlbWVudCBzdGFydAoJbG9hZCAyNTMgLy8gZWxlbWVudCBsZW5ndGgKCSsgLy8gZ2V0IGVuZCBvZiBFbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglsZW4KCXN1YnN0cmluZzMKCWNvbmNhdAoJY29uY2F0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJY2FsbHN1YiAqZ2V0X2xlbmd0aF9kaWZmZXJlbmNlCglsb2FkIDI1MCAvLyBsZW5ndGggZGlmZmVyZW5jZQoJbG9hZCAyNTEgLy8gZWxlbWVudCBoZWFkIG9mZnNldAoJaW50IDIKCSsgLy8gaGVhZCBvZnNldAoJY2FsbHN1YiAqdXBkYXRlX2R5bmFtaWNfaGVhZAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZnJhbWVfZGlnIC0xIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWR1cAoJYm94X2RlbAoJcG9wCglzd2FwCglib3hfcHV0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNjMKCS8vIHRoaXMucGFyY2VsRGVhdGlscyhfdG9rZW5JZCkudmFsdWUuc3RhdHVzPV9zdGF0dXMKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglib3hfZ2V0CgoJLy8gYm94IHZhbHVlIGRvZXMgbm90IGV4aXN0OiB0aGlzLnBhcmNlbERlYXRpbHMoX3Rva2VuSWQpLnZhbHVlCglhc3NlcnQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMgoJZHVwCglzdG9yZSAyNTEgLy8gZWxlbWVudCBoZWFkIG9mZnNldAoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJdW5jb3ZlciAyCglleHRyYWN0X3VpbnQxNgoJZHVwCglzdG9yZSAyNTQgLy8gZWxlbWVudCBzdGFydAoJZHVwIC8vIGR1cGxpY2F0ZSBzdGFydCBvZiBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglleHRyYWN0X3VpbnQxNiAvLyBnZXQgbnVtYmVyIG9mIGVsZW1lbnRzCglpbnQgMSAvLyBnZXQgdHlwZSBsZW5ndGgKCSogLy8gbXVsdGlwbHkgYnkgdHlwZSBsZW5ndGgKCWludCAyCgkrIC8vIGFkZCB0d28gZm9yIGxlbmd0aAoJc3RvcmUgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCglsb2FkIDI1NSAvLyBmdWxsIGFycmF5CglpbnQgMAoJbG9hZCAyNTQgLy8gZWxlbWVudCBzdGFydAoJc3Vic3RyaW5nMwoJZnJhbWVfZGlnIC0zIC8vIF9zdGF0dXM6IHN0cmluZwoJZHVwCglsZW4KCWl0b2IKCWV4dHJhY3QgNiAyCglzd2FwCgljb25jYXQKCWR1cAoJc3RvcmUgMjUyIC8vIG5ldyBlbGVtZW50Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglsb2FkIDI1NCAvLyBlbGVtZW50IHN0YXJ0Cglsb2FkIDI1MyAvLyBlbGVtZW50IGxlbmd0aAoJKyAvLyBnZXQgZW5kIG9mIEVsZW1lbnQKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWxlbgoJc3Vic3RyaW5nMwoJY29uY2F0Cgljb25jYXQKCXN0b3JlIDI1NSAvLyBmdWxsIGFycmF5CgljYWxsc3ViICpnZXRfbGVuZ3RoX2RpZmZlcmVuY2UKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWZyYW1lX2RpZyAtMSAvLyBfdG9rZW5JZDogdWludDY0CglpdG9iCglkdXAKCWJveF9kZWwKCXBvcAoJc3dhcAoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTY0CgkvLyB0aGlzLnBhcmNlbERlYXRpbHMoX3Rva2VuSWQpLnZhbHVlLmxhc3RVcGRhdGVkPV9sYXN0VXBkYXRlZAoJZnJhbWVfZGlnIC0xIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucGFyY2VsRGVhdGlscyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJc3RvcmUgMjU1IC8vIGZ1bGwgYXJyYXkKCWxvYWQgMjU1IC8vIGZ1bGwgYXJyYXkKCWludCA0CglmcmFtZV9kaWcgLTQgLy8gX2xhc3RVcGRhdGVkOiB1aW50NjQKCWl0b2IKCXJlcGxhY2UzCglmcmFtZV9kaWcgLTEgLy8gX3Rva2VuSWQ6IHVpbnQ2NAoJaXRvYgoJZHVwCglib3hfZGVsCglwb3AKCXN3YXAKCWJveF9wdXQKCXJldHN1YgoKLy8gZ2V0UGFyY2VsRGV0YWlscyh1aW50NjQpKHN0cmluZyxzdHJpbmcsdWludDY0KQoqYWJpX3JvdXRlX2dldFBhcmNlbERldGFpbHM6CgkvLyBUaGUgQUJJIHJldHVybiBwcmVmaXgKCWJ5dGUgMHgxNTFmN2M3NQoKCS8vIF90b2tlbklkOiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWJ0b2kKCgkvLyBleGVjdXRlIGdldFBhcmNlbERldGFpbHModWludDY0KShzdHJpbmcsc3RyaW5nLHVpbnQ2NCkKCWNhbGxzdWIgZ2V0UGFyY2VsRGV0YWlscwoJY29uY2F0Cglsb2cKCWludCAxCglyZXR1cm4KCi8vIGdldFBhcmNlbERldGFpbHMoX3Rva2VuSWQ6dWludDY0KTogcGFyY2VsU3RhdHVzCmdldFBhcmNlbERldGFpbHM6Cglwcm90byAxIDEKCgkvLyBjb250cmFjdHMvRE5GVExvZ2lkdGljcy5hbGdvLnRzOjE2OAoJLy8gYXNzZXJ0KHRoaXMucGFyY2VsRGVhdGlscyhfdG9rZW5JZCkuZXhpc3RzKQoJZnJhbWVfZGlnIC0xIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9sZW4KCXN3YXAKCXBvcAoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0RORlRMb2dpZHRpY3MuYWxnby50czoxNjkKCS8vIHJldHVybiB0aGlzLnBhcmNlbERlYXRpbHMoX3Rva2VuSWQpLnZhbHVlOwoJZnJhbWVfZGlnIC0xIC8vIF90b2tlbklkOiB1aW50NjQKCWl0b2IKCWJveF9nZXQKCgkvLyBib3ggdmFsdWUgZG9lcyBub3QgZXhpc3Q6IHRoaXMucGFyY2VsRGVhdGlscyhfdG9rZW5JZCkudmFsdWUKCWFzc2VydAoJcmV0c3ViCgovLyBnZXRBcHBDcmVhdG9yQWRkcmVzcygpYWRkcmVzcwoqYWJpX3JvdXRlX2dldEFwcENyZWF0b3JBZGRyZXNzOgoJLy8gVGhlIEFCSSByZXR1cm4gcHJlZml4CglieXRlIDB4MTUxZjdjNzUKCgkvLyBleGVjdXRlIGdldEFwcENyZWF0b3JBZGRyZXNzKClhZGRyZXNzCgljYWxsc3ViIGdldEFwcENyZWF0b3JBZGRyZXNzCgljb25jYXQKCWxvZwoJaW50IDEKCXJldHVybgoKLy8gZ2V0QXBwQ3JlYXRvckFkZHJlc3MoKTogQWRkcmVzcwpnZXRBcHBDcmVhdG9yQWRkcmVzczoKCXByb3RvIDAgMQoKCS8vIGNvbnRyYWN0cy9ETkZUTG9naWR0aWNzLmFsZ28udHM6MTczCgkvLyByZXR1cm4gdGhpcy5hcHAuY3JlYXRvcjsKCXR4bmEgQXBwbGljYXRpb25zIDAKCWFwcF9wYXJhbXNfZ2V0IEFwcENyZWF0b3IKCXBvcAoJcmV0c3ViCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKHN0cmluZyxzdHJpbmcpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb24KCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY3JlYXRlIE5vT3AKCWVycgoKKmNhbGxfTm9PcDoKCW1ldGhvZCAibmZ0X293bmVyT2YodWludDY0KWFkZHJlc3MiCgltZXRob2QgIm5mdF91cmkodWludDY0KXN0cmluZyIKCW1ldGhvZCAibmZ0X0ltYWdlKHVpbnQ2NClzdHJpbmciCgltZXRob2QgIm5mdF90b3RhbFN1cHBseSgpdWludDY0IgoJbWV0aG9kICJuZnRfZ2V0QXBwcm92ZWQodWludDY0KWFkZHJlc3MiCgltZXRob2QgIm5mdF9pc0FwcHJvdmVkRm9yQWxsKGFkZHJlc3MsYWRkcmVzcylib29sIgoJbWV0aG9kICJuZnRfYmFsYWNlT2YoYWRkcmVzcyl1aW50NjQiCgltZXRob2QgIm5mdF9nZXRBbGxUb2tlbk5mdElkcyhhZGRyZXNzKXVpbnQ2NFtdIgoJbWV0aG9kICJuZnRfZ2V0VG9rZW5EZXRhaWxzKHVpbnQ2NCkoYWRkcmVzcyxzdHJpbmcsc3RyaW5nLGFkZHJlc3MpIgoJbWV0aG9kICJuZnRfYXBwcm92ZShhZGRyZXNzLHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJuZnRfc2V0QXBwcm92YWxGb3JBbGwoYWRkcmVzcyxib29sKXZvaWQiCgltZXRob2QgIm5mdF91cGdyYWRlVXJpKHN0cmluZyx1aW50NjQpdm9pZCIKCW1ldGhvZCAibmZ0X3RyYXNmZXJGcm9tKGFkZHJlc3MsYWRkcmVzcyx1aW50NjQpdm9pZCIKCW1ldGhvZCAibWludChzdHJpbmcsc3RyaW5nLGFkZHJlc3Mpdm9pZCIKCW1ldGhvZCAicmVnaXN0ZXJDb21wYW55KGFkZHJlc3Mpdm9pZCIKCW1ldGhvZCAiY3JlYXRlUGFyY2VsKHN0cmluZyxzdHJpbmcsc3RyaW5nLHN0cmluZyx1aW50NjQpdm9pZCIKCW1ldGhvZCAidXBkYXRlUGFyY2VsKHVpbnQ2NCxzdHJpbmcsc3RyaW5nLHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJnZXRQYXJjZWxEZXRhaWxzKHVpbnQ2NCkoc3RyaW5nLHN0cmluZyx1aW50NjQpIgoJbWV0aG9kICJnZXRBcHBDcmVhdG9yQWRkcmVzcygpYWRkcmVzcyIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfbmZ0X293bmVyT2YgKmFiaV9yb3V0ZV9uZnRfdXJpICphYmlfcm91dGVfbmZ0X0ltYWdlICphYmlfcm91dGVfbmZ0X3RvdGFsU3VwcGx5ICphYmlfcm91dGVfbmZ0X2dldEFwcHJvdmVkICphYmlfcm91dGVfbmZ0X2lzQXBwcm92ZWRGb3JBbGwgKmFiaV9yb3V0ZV9uZnRfYmFsYWNlT2YgKmFiaV9yb3V0ZV9uZnRfZ2V0QWxsVG9rZW5OZnRJZHMgKmFiaV9yb3V0ZV9uZnRfZ2V0VG9rZW5EZXRhaWxzICphYmlfcm91dGVfbmZ0X2FwcHJvdmUgKmFiaV9yb3V0ZV9uZnRfc2V0QXBwcm92YWxGb3JBbGwgKmFiaV9yb3V0ZV9uZnRfdXBncmFkZVVyaSAqYWJpX3JvdXRlX25mdF90cmFzZmVyRnJvbSAqYWJpX3JvdXRlX21pbnQgKmFiaV9yb3V0ZV9yZWdpc3RlckNvbXBhbnkgKmFiaV9yb3V0ZV9jcmVhdGVQYXJjZWwgKmFiaV9yb3V0ZV91cGRhdGVQYXJjZWwgKmFiaV9yb3V0ZV9nZXRQYXJjZWxEZXRhaWxzICphYmlfcm91dGVfZ2V0QXBwQ3JlYXRvckFkZHJlc3MKCgkvLyB0aGlzIGNvbnRyYWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGUgZ2l2ZW4gQUJJIG1ldGhvZCBmb3IgY2FsbCBOb09wCgllcnIKCipwcm9jZXNzX3N0YXRpY190dXBsZV9lbGVtZW50OgoJcHJvdG8gNCAzCglmcmFtZV9kaWcgLTQgLy8gdHVwbGUgaGVhZAoJZnJhbWVfZGlnIC0xIC8vIGVsZW1lbnQKCWNvbmNhdAoJZnJhbWVfZGlnIC0zIC8vIHR1cGxlIHRhaWwKCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJcmV0c3ViCgoqcHJvY2Vzc19keW5hbWljX3R1cGxlX2VsZW1lbnQ6Cglwcm90byA0IDMKCWZyYW1lX2RpZyAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCWNvbmNhdAoJZnJhbWVfYnVyeSAtNCAvLyB0dXBsZSBoZWFkCglmcmFtZV9kaWcgLTEgLy8gZWxlbWVudAoJZHVwCglsZW4KCWZyYW1lX2RpZyAtMiAvLyBoZWFkIG9mZnNldAoJYnRvaQoJKwoJaXRvYgoJZXh0cmFjdCA2IDIKCWZyYW1lX2J1cnkgLTIgLy8gaGVhZCBvZmZzZXQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglzd2FwCgljb25jYXQKCWZyYW1lX2J1cnkgLTMgLy8gdHVwbGUgdGFpbAoJZnJhbWVfZGlnIC00IC8vIHR1cGxlIGhlYWQKCWZyYW1lX2RpZyAtMyAvLyB0dXBsZSB0YWlsCglmcmFtZV9kaWcgLTIgLy8gaGVhZCBvZmZzZXQKCXJldHN1YgoKKnVwZGF0ZV9keW5hbWljX2hlYWQ6Cglwcm90byAyIDAKCWZyYW1lX2RpZyAtMiAvLyBsZW5ndGggZGlmZmVyZW5jZQoJbG9hZCAyNTUgLy8gZnVsbCBhcnJheQoJZnJhbWVfZGlnIC0xIC8vIGR5bmFtaWMgYXJyYXkgb2Zmc2V0CglleHRyYWN0X3VpbnQxNiAvLyBleHRyYWN0IGR5bmFtaWMgYXJyYXkgb2Zmc2V0Cglsb2FkIDI0OSAvLyBzdWJ0cmFjdCBoZWFkIGRpZmZlcmVuY2UKCWJ6ICpzdWJ0cmFjdF9oZWFkX2RpZmZlcmVuY2UKCSsgLy8gYWRkIGRpZmZlcmVuY2UgdG8gb2Zmc2V0CgliICplbmRfY2FsY19uZXdfaGVhZAoKKnN1YnRyYWN0X2hlYWRfZGlmZmVyZW5jZToKCXN3YXAKCS0gLy8gc3VidHJhY3QgZGlmZmVyZW5jZSBmcm9tIG9mZmV0CgoqZW5kX2NhbGNfbmV3X2hlYWQ6CglpdG9iIC8vIGNvbnZlcnQgdG8gYnl0ZXMKCWV4dHJhY3QgNiAyIC8vIGNvbnZlcnQgdG8gdWludDE2Cglsb2FkIDI1NSAvLyBmdWxsIGFycmF5Cglzd2FwCglmcmFtZV9kaWcgLTEgLy8gb2Zmc2V0Cglzd2FwCglyZXBsYWNlMyAvLyB1cGRhdGUgb2Zmc2V0CglzdG9yZSAyNTUgLy8gZnVsbCBhcnJheQoJcmV0c3ViCgoqZ2V0X2xlbmd0aF9kaWZmZXJlbmNlOgoJbG9hZCAyNTIgLy8gbmV3IGVsZW1lbnQKCWxlbiAvLyBsZW5ndGggb2YgbmV3IGVsZW1lbnQKCWxvYWQgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCgk8CglibnogKnN3YXBwZWRfZGlmZmVyZW5jZQoJbG9hZCAyNTIgLy8gbmV3IGVsZW1lbnQKCWxlbiAvLyBsZW5ndGggb2YgbmV3IGVsZW1lbnQKCWxvYWQgMjUzIC8vIGVsZW1lbnQgbGVuZ3RoCglpbnQgMQoJc3RvcmUgMjQ5IC8vIHN1YnRyYWN0IGhlYWQgZGlmZmVyZW5jZQoJYiAqZ2V0X2RpZmZlcmVuY2UKCipzd2FwcGVkX2RpZmZlcmVuY2U6Cglsb2FkIDI1MyAvLyBlbGVtZW50IGxlbmd0aAoJbG9hZCAyNTIgLy8gbmV3IGVsZW1lbnQKCWxlbiAvLyBsZW5ndGggb2YgbmV3IGVsZW1lbnQKCWludCAwCglzdG9yZSAyNDkgLy8gc3VidHJhY3QgaGVhZCBkaWZmZXJlbmNlCgoqZ2V0X2RpZmZlcmVuY2U6CgktIC8vIGdldCBsZW5ndGggZGlmZmVyZW5jZQoJc3RvcmUgMjUwIC8vIGxlbmd0aCBkaWZmZXJlbmNlCglyZXRzdWI=",
    "clear": "I3ByYWdtYSB2ZXJzaW9uIDEw"
  },
  "contract": {
    "name": "DNFTLogidtics",
    "desc": "",
    "methods": [
      {
        "name": "createApplication",
        "args": [
          {
            "name": "_name",
            "type": "string"
          },
          {
            "name": "_symbol",
            "type": "string"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "nft_ownerOf",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "address"
        }
      },
      {
        "name": "nft_uri",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "string"
        }
      },
      {
        "name": "nft_Image",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "string"
        }
      },
      {
        "name": "nft_totalSupply",
        "args": [],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "nft_getApproved",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "address"
        }
      },
      {
        "name": "nft_isApprovedForAll",
        "args": [
          {
            "name": "_owner",
            "type": "address"
          },
          {
            "name": "_operator",
            "type": "address"
          }
        ],
        "returns": {
          "type": "bool"
        }
      },
      {
        "name": "nft_balaceOf",
        "args": [
          {
            "name": "_owner",
            "type": "address"
          }
        ],
        "returns": {
          "type": "uint64"
        }
      },
      {
        "name": "nft_getAllTokenNftIds",
        "args": [
          {
            "name": "_owner",
            "type": "address"
          }
        ],
        "returns": {
          "type": "uint64[]"
        }
      },
      {
        "name": "nft_getTokenDetails",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(address,string,string,address)"
        }
      },
      {
        "name": "nft_approve",
        "args": [
          {
            "name": "_approved",
            "type": "address"
          },
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "nft_setApprovalForAll",
        "args": [
          {
            "name": "_operator",
            "type": "address"
          },
          {
            "name": "_approved",
            "type": "bool"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "nft_upgradeUri",
        "args": [
          {
            "name": "_tokenUri",
            "type": "string"
          },
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "nft_trasferFrom",
        "args": [
          {
            "name": "_from",
            "type": "address"
          },
          {
            "name": "_to",
            "type": "address"
          },
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "mint",
        "args": [
          {
            "name": "_image",
            "type": "string"
          },
          {
            "name": "_tokenUri",
            "type": "string"
          },
          {
            "name": "_to",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "registerCompany",
        "args": [
          {
            "name": "_companyAddress",
            "type": "address"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "createParcel",
        "args": [
          {
            "name": "_image",
            "type": "string"
          },
          {
            "name": "_tokenUri",
            "type": "string"
          },
          {
            "name": "_initialLocation",
            "type": "string"
          },
          {
            "name": "_status",
            "type": "string"
          },
          {
            "name": "_lastUpdated",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "updateParcel",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          },
          {
            "name": "_currentLocation",
            "type": "string"
          },
          {
            "name": "_status",
            "type": "string"
          },
          {
            "name": "_lastUpdated",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "void"
        }
      },
      {
        "name": "getParcelDetails",
        "args": [
          {
            "name": "_tokenId",
            "type": "uint64"
          }
        ],
        "returns": {
          "type": "(string,string,uint64)"
        }
      },
      {
        "name": "getAppCreatorAddress",
        "args": [],
        "returns": {
          "type": "address"
        }
      }
    ]
  }
}

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp =  { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC }
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn =  { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC }
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut =  { onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC }
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp =  { onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC }
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp =  { onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC }
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint
  /**
   * Gets the state value as a number.
   */
  asNumber(): number
}
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array
  /**
   * Gets the state value as a string
   */
  asString(): string
}

export type AppCreateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult> & AppReference
export type AppUpdateCallTransactionResult = AppCallTransactionResult & Partial<AppCompilationResult>

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<SendTransactionParams, 'skipSending' | 'atc' | 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources'>
}
export type AppClientComposeExecuteParams = Pick<SendTransactionParams, 'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'>

/**
 * Defines the types of available calls and state of the DnftLogidtics smart contract.
 */
export type DnftLogidtics = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'createApplication(string,string)void' | 'createApplication', {
      argsObj: {
        _name: string
        _symbol: string
      }
      argsTuple: [_name: string, _symbol: string]
      returns: void
    }>
    & Record<'nft_ownerOf(uint64)address' | 'nft_ownerOf', {
      argsObj: {
        _tokenId: bigint | number
      }
      argsTuple: [_tokenId: bigint | number]
      returns: string
    }>
    & Record<'nft_uri(uint64)string' | 'nft_uri', {
      argsObj: {
        _tokenId: bigint | number
      }
      argsTuple: [_tokenId: bigint | number]
      returns: string
    }>
    & Record<'nft_Image(uint64)string' | 'nft_Image', {
      argsObj: {
        _tokenId: bigint | number
      }
      argsTuple: [_tokenId: bigint | number]
      returns: string
    }>
    & Record<'nft_totalSupply()uint64' | 'nft_totalSupply', {
      argsObj: {
      }
      argsTuple: []
      returns: bigint
    }>
    & Record<'nft_getApproved(uint64)address' | 'nft_getApproved', {
      argsObj: {
        _tokenId: bigint | number
      }
      argsTuple: [_tokenId: bigint | number]
      returns: string
    }>
    & Record<'nft_isApprovedForAll(address,address)bool' | 'nft_isApprovedForAll', {
      argsObj: {
        _owner: string
        _operator: string
      }
      argsTuple: [_owner: string, _operator: string]
      returns: boolean
    }>
    & Record<'nft_balaceOf(address)uint64' | 'nft_balaceOf', {
      argsObj: {
        _owner: string
      }
      argsTuple: [_owner: string]
      returns: bigint
    }>
    & Record<'nft_getAllTokenNftIds(address)uint64[]' | 'nft_getAllTokenNftIds', {
      argsObj: {
        _owner: string
      }
      argsTuple: [_owner: string]
      returns: bigint[]
    }>
    & Record<'nft_getTokenDetails(uint64)(address,string,string,address)' | 'nft_getTokenDetails', {
      argsObj: {
        _tokenId: bigint | number
      }
      argsTuple: [_tokenId: bigint | number]
      returns: [string, string, string, string]
    }>
    & Record<'nft_approve(address,uint64)void' | 'nft_approve', {
      argsObj: {
        _approved: string
        _tokenId: bigint | number
      }
      argsTuple: [_approved: string, _tokenId: bigint | number]
      returns: void
    }>
    & Record<'nft_setApprovalForAll(address,bool)void' | 'nft_setApprovalForAll', {
      argsObj: {
        _operator: string
        _approved: boolean
      }
      argsTuple: [_operator: string, _approved: boolean]
      returns: void
    }>
    & Record<'nft_upgradeUri(string,uint64)void' | 'nft_upgradeUri', {
      argsObj: {
        _tokenUri: string
        _tokenId: bigint | number
      }
      argsTuple: [_tokenUri: string, _tokenId: bigint | number]
      returns: void
    }>
    & Record<'nft_trasferFrom(address,address,uint64)void' | 'nft_trasferFrom', {
      argsObj: {
        _from: string
        _to: string
        _tokenId: bigint | number
      }
      argsTuple: [_from: string, _to: string, _tokenId: bigint | number]
      returns: void
    }>
    & Record<'mint(string,string,address)void' | 'mint', {
      argsObj: {
        _image: string
        _tokenUri: string
        _to: string
      }
      argsTuple: [_image: string, _tokenUri: string, _to: string]
      returns: void
    }>
    & Record<'registerCompany(address)void' | 'registerCompany', {
      argsObj: {
        _companyAddress: string
      }
      argsTuple: [_companyAddress: string]
      returns: void
    }>
    & Record<'createParcel(string,string,string,string,uint64)void' | 'createParcel', {
      argsObj: {
        _image: string
        _tokenUri: string
        _initialLocation: string
        _status: string
        _lastUpdated: bigint | number
      }
      argsTuple: [_image: string, _tokenUri: string, _initialLocation: string, _status: string, _lastUpdated: bigint | number]
      returns: void
    }>
    & Record<'updateParcel(uint64,string,string,uint64)void' | 'updateParcel', {
      argsObj: {
        _tokenId: bigint | number
        _currentLocation: string
        _status: string
        _lastUpdated: bigint | number
      }
      argsTuple: [_tokenId: bigint | number, _currentLocation: string, _status: string, _lastUpdated: bigint | number]
      returns: void
    }>
    & Record<'getParcelDetails(uint64)(string,string,uint64)' | 'getParcelDetails', {
      argsObj: {
        _tokenId: bigint | number
      }
      argsTuple: [_tokenId: bigint | number]
      returns: [string, string, bigint]
    }>
    & Record<'getAppCreatorAddress()address' | 'getAppCreatorAddress', {
      argsObj: {
      }
      argsTuple: []
      returns: string
    }>
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      'counter'?: IntegerState
      'name'?: BinaryState
      'symbol'?: BinaryState
    }
  }
}
/**
 * Defines the possible abi call signatures
 */
export type DnftLogidticsSig = keyof DnftLogidtics['methods']
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends DnftLogidticsSig | undefined> = {
  method: TSignature
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>
} & AppClientCallCoreParams & CoreAppCallArgs
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>
/**
 * Maps a method signature from the DnftLogidtics smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends DnftLogidticsSig> = DnftLogidtics['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the DnftLogidtics smart contract to the method's return type
 */
export type MethodReturn<TSignature extends DnftLogidticsSig> = DnftLogidtics['methods'][TSignature]['returns']

/**
 * A factory for available 'create' calls
 */
export type DnftLogidticsCreateCalls = (typeof DnftLogidticsCallFactory)['create']
/**
 * Defines supported create methods for this smart contract
 */
export type DnftLogidticsCreateCallParams =
  | (TypedCallParams<'createApplication(string,string)void'> & (OnCompleteNoOp))
/**
 * Defines arguments required for the deploy method.
 */
export type DnftLogidticsDeployArgs = {
  deployTimeParams?: TealTemplateParams
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: DnftLogidticsCreateCalls) => DnftLogidticsCreateCallParams
}


/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class DnftLogidticsCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the DNFTLogidtics smart contract using the createApplication(string,string)void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(args: MethodArgs<'createApplication(string,string)void'>, params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return {
          method: 'createApplication(string,string)void' as const,
          methodArgs: Array.isArray(args) ? args : [args._name, args._symbol],
          ...params,
        }
      },
    }
  }

  /**
   * Constructs a no op call for the nft_ownerOf(uint64)address ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftOwnerOf(args: MethodArgs<'nft_ownerOf(uint64)address'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_ownerOf(uint64)address' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_uri(uint64)string ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftUri(args: MethodArgs<'nft_uri(uint64)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_uri(uint64)string' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_Image(uint64)string ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftImage(args: MethodArgs<'nft_Image(uint64)string'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_Image(uint64)string' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_totalSupply()uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftTotalSupply(args: MethodArgs<'nft_totalSupply()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_totalSupply()uint64' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_getApproved(uint64)address ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftGetApproved(args: MethodArgs<'nft_getApproved(uint64)address'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_getApproved(uint64)address' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_isApprovedForAll(address,address)bool ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftIsApprovedForAll(args: MethodArgs<'nft_isApprovedForAll(address,address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_isApprovedForAll(address,address)bool' as const,
      methodArgs: Array.isArray(args) ? args : [args._owner, args._operator],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_balaceOf(address)uint64 ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftBalaceOf(args: MethodArgs<'nft_balaceOf(address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_balaceOf(address)uint64' as const,
      methodArgs: Array.isArray(args) ? args : [args._owner],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_getAllTokenNftIds(address)uint64[] ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftGetAllTokenNftIds(args: MethodArgs<'nft_getAllTokenNftIds(address)uint64[]'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_getAllTokenNftIds(address)uint64[]' as const,
      methodArgs: Array.isArray(args) ? args : [args._owner],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_getTokenDetails(uint64)(address,string,string,address) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftGetTokenDetails(args: MethodArgs<'nft_getTokenDetails(uint64)(address,string,string,address)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_getTokenDetails(uint64)(address,string,string,address)' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_approve(address,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftApprove(args: MethodArgs<'nft_approve(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_approve(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._approved, args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_setApprovalForAll(address,bool)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftSetApprovalForAll(args: MethodArgs<'nft_setApprovalForAll(address,bool)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_setApprovalForAll(address,bool)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._operator, args._approved],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_upgradeUri(string,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftUpgradeUri(args: MethodArgs<'nft_upgradeUri(string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_upgradeUri(string,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenUri, args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the nft_trasferFrom(address,address,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static nftTrasferFrom(args: MethodArgs<'nft_trasferFrom(address,address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'nft_trasferFrom(address,address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._from, args._to, args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the mint(string,string,address)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static mint(args: MethodArgs<'mint(string,string,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'mint(string,string,address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._image, args._tokenUri, args._to],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the registerCompany(address)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static registerCompany(args: MethodArgs<'registerCompany(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'registerCompany(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._companyAddress],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the createParcel(string,string,string,string,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static createParcel(args: MethodArgs<'createParcel(string,string,string,string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'createParcel(string,string,string,string,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._image, args._tokenUri, args._initialLocation, args._status, args._lastUpdated],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the updateParcel(uint64,string,string,uint64)void ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static updateParcel(args: MethodArgs<'updateParcel(uint64,string,string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'updateParcel(uint64,string,string,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId, args._currentLocation, args._status, args._lastUpdated],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getParcelDetails(uint64)(string,string,uint64) ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getParcelDetails(args: MethodArgs<'getParcelDetails(uint64)(string,string,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getParcelDetails(uint64)(string,string,uint64)' as const,
      methodArgs: Array.isArray(args) ? args : [args._tokenId],
      ...params,
    }
  }
  /**
   * Constructs a no op call for the getAppCreatorAddress()address ABI method
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static getAppCreatorAddress(args: MethodArgs<'getAppCreatorAddress()address'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'getAppCreatorAddress()address' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    }
  }
}

/**
 * A client to make calls to the DNFTLogidtics smart contract
 */
export class DnftLogidticsClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient

  private readonly sender: SendTransactionFrom | undefined

  /**
   * Creates a new instance of `DnftLogidticsClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender
    this.appClient = algokit.getAppClient({
      ...appDetails,
      app: APP_SPEC
    }, algod)
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<TReturn, TResult extends AppCallTransactionResult = AppCallTransactionResult>(result: AppCallTransactionResult, returnValueFormatter?: (value: any) => TReturn): AppCallTransactionResultOfType<TReturn> & TResult {
    if(result.return?.decodeError) {
      throw result.return.decodeError
    }
    const returnValue = result.return?.returnValue !== undefined && returnValueFormatter !== undefined
      ? returnValueFormatter(result.return.returnValue)
      : result.return?.returnValue as TReturn | undefined
      return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof DnftLogidtics['methods']>(typedCallParams: TypedCallParams<TSignature>, returnValueFormatter?: (value: any) => MethodReturn<TSignature>) {
    return this.mapReturnValue<MethodReturn<TSignature>>(await this.appClient.call(typedCallParams), returnValueFormatter)
  }

  /**
   * Idempotently deploys the DNFTLogidtics smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(params: DnftLogidticsDeployArgs & AppClientDeployCoreParams = {}): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(DnftLogidticsCallFactory.create)
    return this.appClient.deploy({
      ...params,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    })
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this
    return {
      /**
       * Creates a new instance of the DNFTLogidtics smart contract using the createApplication(string,string)void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(args: MethodArgs<'createApplication(string,string)void'>, params: AppClientCallCoreParams & AppClientCompilationParams & (OnCompleteNoOp) = {}) {
        return $this.mapReturnValue<MethodReturn<'createApplication(string,string)void'>, AppCreateCallTransactionResult>(await $this.appClient.create(DnftLogidticsCallFactory.create.createApplication(args, params)))
      },
    }
  }

  /**
   * Makes a clear_state call to an existing instance of the DNFTLogidtics smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args)
  }

  /**
   * Calls the nft_ownerOf(uint64)address ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftOwnerOf(args: MethodArgs<'nft_ownerOf(uint64)address'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftOwnerOf(args, params))
  }

  /**
   * Calls the nft_uri(uint64)string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftUri(args: MethodArgs<'nft_uri(uint64)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftUri(args, params))
  }

  /**
   * Calls the nft_Image(uint64)string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftImage(args: MethodArgs<'nft_Image(uint64)string'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftImage(args, params))
  }

  /**
   * Calls the nft_totalSupply()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftTotalSupply(args: MethodArgs<'nft_totalSupply()uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftTotalSupply(args, params))
  }

  /**
   * Calls the nft_getApproved(uint64)address ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftGetApproved(args: MethodArgs<'nft_getApproved(uint64)address'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftGetApproved(args, params))
  }

  /**
   * Calls the nft_isApprovedForAll(address,address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftIsApprovedForAll(args: MethodArgs<'nft_isApprovedForAll(address,address)bool'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftIsApprovedForAll(args, params))
  }

  /**
   * Calls the nft_balaceOf(address)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftBalaceOf(args: MethodArgs<'nft_balaceOf(address)uint64'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftBalaceOf(args, params))
  }

  /**
   * Calls the nft_getAllTokenNftIds(address)uint64[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftGetAllTokenNftIds(args: MethodArgs<'nft_getAllTokenNftIds(address)uint64[]'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftGetAllTokenNftIds(args, params))
  }

  /**
   * Calls the nft_getTokenDetails(uint64)(address,string,string,address) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftGetTokenDetails(args: MethodArgs<'nft_getTokenDetails(uint64)(address,string,string,address)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftGetTokenDetails(args, params))
  }

  /**
   * Calls the nft_approve(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftApprove(args: MethodArgs<'nft_approve(address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftApprove(args, params))
  }

  /**
   * Calls the nft_setApprovalForAll(address,bool)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftSetApprovalForAll(args: MethodArgs<'nft_setApprovalForAll(address,bool)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftSetApprovalForAll(args, params))
  }

  /**
   * Calls the nft_upgradeUri(string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftUpgradeUri(args: MethodArgs<'nft_upgradeUri(string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftUpgradeUri(args, params))
  }

  /**
   * Calls the nft_trasferFrom(address,address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public nftTrasferFrom(args: MethodArgs<'nft_trasferFrom(address,address,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.nftTrasferFrom(args, params))
  }

  /**
   * Calls the mint(string,string,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public mint(args: MethodArgs<'mint(string,string,address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.mint(args, params))
  }

  /**
   * Calls the registerCompany(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public registerCompany(args: MethodArgs<'registerCompany(address)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.registerCompany(args, params))
  }

  /**
   * Calls the createParcel(string,string,string,string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public createParcel(args: MethodArgs<'createParcel(string,string,string,string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.createParcel(args, params))
  }

  /**
   * Calls the updateParcel(uint64,string,string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public updateParcel(args: MethodArgs<'updateParcel(uint64,string,string,uint64)void'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.updateParcel(args, params))
  }

  /**
   * Calls the getParcelDetails(uint64)(string,string,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getParcelDetails(args: MethodArgs<'getParcelDetails(uint64)(string,string,uint64)'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.getParcelDetails(args, params))
  }

  /**
   * Calls the getAppCreatorAddress()address ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public getAppCreatorAddress(args: MethodArgs<'getAppCreatorAddress()address'>, params: AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.call(DnftLogidticsCallFactory.getAppCreatorAddress(args, params))
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key]
    if (!value) return undefined
    if (!('valueRaw' in value))
      throw new Error(`Failed to parse state value for ${key}; received an int when expected a byte array`)
    return {
      asString(): string {
        return value.value
      },
      asByteArray(): Uint8Array {
        return value.valueRaw
      }
    }
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key]
    if (!value) return undefined
    if ('valueRaw' in value)
      throw new Error(`Failed to parse state value for ${key}; received a byte array when expected a number`)
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value)
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value
      },
    }
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<DnftLogidtics['state']['global']> {
    const state = await this.appClient.getGlobalState()
    return {
      get counter() {
        return DnftLogidticsClient.getIntegerState(state, 'counter')
      },
      get name() {
        return DnftLogidticsClient.getBinaryState(state, 'name')
      },
      get symbol() {
        return DnftLogidticsClient.getBinaryState(state, 'symbol')
      },
    }
  }

  public compose(): DnftLogidticsComposer {
    const client = this
    const atc = new AtomicTransactionComposer()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: any) => any)> = []
    return {
      nftOwnerOf(args: MethodArgs<'nft_ownerOf(uint64)address'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftOwnerOf(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftUri(args: MethodArgs<'nft_uri(uint64)string'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftUri(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftImage(args: MethodArgs<'nft_Image(uint64)string'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftImage(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftTotalSupply(args: MethodArgs<'nft_totalSupply()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftTotalSupply(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftGetApproved(args: MethodArgs<'nft_getApproved(uint64)address'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftGetApproved(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftIsApprovedForAll(args: MethodArgs<'nft_isApprovedForAll(address,address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftIsApprovedForAll(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftBalaceOf(args: MethodArgs<'nft_balaceOf(address)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftBalaceOf(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftGetAllTokenNftIds(args: MethodArgs<'nft_getAllTokenNftIds(address)uint64[]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftGetAllTokenNftIds(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftGetTokenDetails(args: MethodArgs<'nft_getTokenDetails(uint64)(address,string,string,address)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftGetTokenDetails(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftApprove(args: MethodArgs<'nft_approve(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftApprove(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftSetApprovalForAll(args: MethodArgs<'nft_setApprovalForAll(address,bool)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftSetApprovalForAll(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftUpgradeUri(args: MethodArgs<'nft_upgradeUri(string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftUpgradeUri(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      nftTrasferFrom(args: MethodArgs<'nft_trasferFrom(address,address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.nftTrasferFrom(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      mint(args: MethodArgs<'mint(string,string,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.mint(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      registerCompany(args: MethodArgs<'registerCompany(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.registerCompany(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      createParcel(args: MethodArgs<'createParcel(string,string,string,string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.createParcel(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      updateParcel(args: MethodArgs<'updateParcel(uint64,string,string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.updateParcel(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getParcelDetails(args: MethodArgs<'getParcelDetails(uint64)(string,string,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getParcelDetails(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      getAppCreatorAddress(args: MethodArgs<'getAppCreatorAddress()address'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.getAppCreatorAddress(args, {...params, sendParams: {...params?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() => client.clearState({...args, sendParams: {...args?.sendParams, skipSending: true, atc}}))
        resultMappers.push(undefined)
        return this
      },
      addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom) {
        promiseChain = promiseChain.then(async () => atc.addTransaction(await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender)))
        return this
      },
      async atc() {
        await promiseChain
        return atc
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await atc.simulate(client.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }))
        return {
          ...result,
          returns: result.methodResults?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain
        const result = await algokit.sendAtomicTransactionComposer({ atc, sendParams }, client.algod)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue)
        }
      }
    } as unknown as DnftLogidticsComposer
  }
}
export type DnftLogidticsComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the nft_ownerOf(uint64)address ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftOwnerOf(args: MethodArgs<'nft_ownerOf(uint64)address'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_ownerOf(uint64)address'>]>

  /**
   * Calls the nft_uri(uint64)string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftUri(args: MethodArgs<'nft_uri(uint64)string'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_uri(uint64)string'>]>

  /**
   * Calls the nft_Image(uint64)string ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftImage(args: MethodArgs<'nft_Image(uint64)string'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_Image(uint64)string'>]>

  /**
   * Calls the nft_totalSupply()uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftTotalSupply(args: MethodArgs<'nft_totalSupply()uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_totalSupply()uint64'>]>

  /**
   * Calls the nft_getApproved(uint64)address ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftGetApproved(args: MethodArgs<'nft_getApproved(uint64)address'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_getApproved(uint64)address'>]>

  /**
   * Calls the nft_isApprovedForAll(address,address)bool ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftIsApprovedForAll(args: MethodArgs<'nft_isApprovedForAll(address,address)bool'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_isApprovedForAll(address,address)bool'>]>

  /**
   * Calls the nft_balaceOf(address)uint64 ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftBalaceOf(args: MethodArgs<'nft_balaceOf(address)uint64'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_balaceOf(address)uint64'>]>

  /**
   * Calls the nft_getAllTokenNftIds(address)uint64[] ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftGetAllTokenNftIds(args: MethodArgs<'nft_getAllTokenNftIds(address)uint64[]'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_getAllTokenNftIds(address)uint64[]'>]>

  /**
   * Calls the nft_getTokenDetails(uint64)(address,string,string,address) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftGetTokenDetails(args: MethodArgs<'nft_getTokenDetails(uint64)(address,string,string,address)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_getTokenDetails(uint64)(address,string,string,address)'>]>

  /**
   * Calls the nft_approve(address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftApprove(args: MethodArgs<'nft_approve(address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_approve(address,uint64)void'>]>

  /**
   * Calls the nft_setApprovalForAll(address,bool)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftSetApprovalForAll(args: MethodArgs<'nft_setApprovalForAll(address,bool)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_setApprovalForAll(address,bool)void'>]>

  /**
   * Calls the nft_upgradeUri(string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftUpgradeUri(args: MethodArgs<'nft_upgradeUri(string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_upgradeUri(string,uint64)void'>]>

  /**
   * Calls the nft_trasferFrom(address,address,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  nftTrasferFrom(args: MethodArgs<'nft_trasferFrom(address,address,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'nft_trasferFrom(address,address,uint64)void'>]>

  /**
   * Calls the mint(string,string,address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  mint(args: MethodArgs<'mint(string,string,address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'mint(string,string,address)void'>]>

  /**
   * Calls the registerCompany(address)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  registerCompany(args: MethodArgs<'registerCompany(address)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'registerCompany(address)void'>]>

  /**
   * Calls the createParcel(string,string,string,string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  createParcel(args: MethodArgs<'createParcel(string,string,string,string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'createParcel(string,string,string,string,uint64)void'>]>

  /**
   * Calls the updateParcel(uint64,string,string,uint64)void ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateParcel(args: MethodArgs<'updateParcel(uint64,string,string,uint64)void'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'updateParcel(uint64,string,string,uint64)void'>]>

  /**
   * Calls the getParcelDetails(uint64)(string,string,uint64) ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getParcelDetails(args: MethodArgs<'getParcelDetails(uint64)(string,string,uint64)'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'getParcelDetails(uint64)(string,string,uint64)'>]>

  /**
   * Calls the getAppCreatorAddress()address ABI method.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getAppCreatorAddress(args: MethodArgs<'getAppCreatorAddress()address'>, params?: AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, MethodReturn<'getAppCreatorAddress()address'>]>

  /**
   * Makes a clear_state call to an existing instance of the DNFTLogidtics smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs): DnftLogidticsComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>, defaultSender?: SendTransactionFrom): DnftLogidticsComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<DnftLogidticsComposerSimulateResult<TReturns>>
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<DnftLogidticsComposerResults<TReturns>>
}
export type SimulateOptions = Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>
export type DnftLogidticsComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns
  methodResults: ABIResult[]
  simulateResponse: modelsv2.SimulateResponse
}
export type DnftLogidticsComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns
  groupId: string
  txIds: string[]
  transactions: Transaction[]
}
