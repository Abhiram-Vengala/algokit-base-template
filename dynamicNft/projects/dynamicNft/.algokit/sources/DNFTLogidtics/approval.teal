#pragma version 10

// This TEAL was generated by TEALScript v0.103.0
// https://github.com/algorandfoundation/TEALScript

// This contract is compliant with and/or implements the following ARCs: [ ARC4 ]

// The following ten lines of TEAL handle initial program flow
// This pattern is used to make it easy for anyone to parse the start of the program and determine if a specific action is allowed
// Here, action refers to the OnComplete in combination with whether the app is being created or called
// Every possible action for this contract is represented in the switch statement
// If the action is not implemented in the contract, its respective branch will be "*NOT_IMPLEMENTED" which just contains "err"
txn ApplicationID
!
int 6
*
txn OnCompletion
+
switch *call_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *create_NoOp *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED *NOT_IMPLEMENTED

*NOT_IMPLEMENTED:
	// The requested action is not implemented in this contract. Are you using the correct OnComplete? Did you set your app ID?
	err

// createApplication(string,string)void
*abi_route_createApplication:
	// _symbol: string
	txna ApplicationArgs 2
	extract 2 0

	// _name: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createApplication(string,string)void
	callsub createApplication
	int 1
	return

// createApplication(_name:string, _symbol:string): void
createApplication:
	proto 2 0

	// contracts/DNFTLogidtics.algo.ts:15
	// this.name.value = _name
	byte 0x6e616d65 // "name"
	frame_dig -1 // _name: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put

	// contracts/DNFTLogidtics.algo.ts:16
	// this.symbol.value = _symbol
	byte 0x73796d626f6c // "symbol"
	frame_dig -2 // _symbol: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	app_global_put
	retsub

// updateTransfer(_from:Address, _to:Address, _tokenId:uint64): void
updateTransfer:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dupn 2

	// contracts/DNFTLogidtics.algo.ts:20
	// index:uint64 = 0
	int 0
	frame_bury 0 // index: uint64

	// contracts/DNFTLogidtics.algo.ts:21
	// i:uint64 =0
	int 0
	frame_bury 1 // i: uint64

	// contracts/DNFTLogidtics.algo.ts:22
	// len = this.ownerBox(_from).value.length
	frame_dig -1 // _from: Address
	box_get

	// box value does not exist: this.ownerBox(_from).value
	assert
	extract 2 0
	len
	int 8
	/
	frame_bury 2 // len: uint64

	// contracts/DNFTLogidtics.algo.ts:24
	// for(i;i<len;i=i+1)
	frame_dig 1 // i: uint64

*for_0:
	// contracts/DNFTLogidtics.algo.ts:24
	// i<len
	frame_dig 1 // i: uint64
	frame_dig 2 // len: uint64
	<
	bz *for_0_end

	// *if0_condition
	// contracts/DNFTLogidtics.algo.ts:25
	// this.ownerBox(_from).value[i]===_tokenId
	frame_dig -1 // _from: Address
	box_get

	// box value does not exist: this.ownerBox(_from).value
	assert
	extract 2 0
	store 255 // full array
	int 0 // initial offset
	frame_dig 1 // i: uint64
	int 8
	* // acc * typeLength
	+
	load 255 // full array
	swap
	int 8
	extract3
	btoi
	frame_dig -3 // _tokenId: uint64
	==
	bz *if0_end

	// *if0_consequent
	// contracts/DNFTLogidtics.algo.ts:26
	// index =1
	int 1
	frame_bury 0 // index: uint64

*if0_end:

*for_0_continue:
	// contracts/DNFTLogidtics.algo.ts:24
	// i=i+1
	frame_dig 1 // i: uint64
	int 1
	+
	frame_bury 1 // i: uint64
	b *for_0

*for_0_end:
	// contracts/DNFTLogidtics.algo.ts:29
	// this.ownerBox(_from).value.splice(index,1)
	frame_dig -1 // _from: Address
	box_get

	// box value does not exist: this.ownerBox(_from).value
	assert
	extract 2 0
	int 1
	frame_dig 0 // index: uint64
	int 8
	*
	store 247 // splice start
	int 16
	store 246 // splice byte length
	frame_dig -1 // _from: Address
	box_get

	// box value does not exist: this.ownerBox(_from).value
	assert
	extract 2 0
	int 0
	load 247 // splice start
	substring3
	frame_dig -1 // _from: Address
	box_get

	// box value does not exist: this.ownerBox(_from).value
	assert
	extract 2 0
	dup
	len
	load 247 // splice start
	load 246 // splice byte length
	+
	int 8
	-
	swap
	substring3
	concat
	frame_dig -1 // _from: Address
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

	// *if1_condition
	// contracts/DNFTLogidtics.algo.ts:30
	// this.ownerBox(_to).exists
	frame_dig -2 // _to: Address
	box_len
	swap
	pop
	bz *if1_else

	// *if1_consequent
	// contracts/DNFTLogidtics.algo.ts:31
	// this.ownerBox(_to).value.push(_tokenId)
	frame_dig -2 // _to: Address
	box_get

	// box value does not exist: this.ownerBox(_to).value
	assert
	extract 2 0
	frame_dig -3 // _tokenId: uint64
	itob
	concat
	frame_dig -2 // _to: Address
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	b *if1_end

*if1_else:
	// contracts/DNFTLogidtics.algo.ts:33
	// this.ownerBox(_to).value = [_tokenId]
	frame_dig -2 // _to: Address
	dup
	box_del
	pop
	frame_dig -3 // _tokenId: uint64
	itob
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

*if1_end:
	retsub

// transferTo(_to:Address, _tokenId:uint64): void
transferTo:
	proto 2 0

	// contracts/DNFTLogidtics.algo.ts:38
	// assert(this.tokens(_tokenId).exists)
	frame_dig -2 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:39
	// this.tokens(_tokenId).value.owner = _to
	frame_dig -2 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	int 0
	frame_dig -1 // _to: Address
	replace3
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

	// contracts/DNFTLogidtics.algo.ts:40
	// this.tokens(_tokenId).value.control = globals.zeroAddress
	frame_dig -2 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	int 36
	global ZeroAddress
	replace3
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// nft_ownerOf(uint64)address
*abi_route_nft_ownerOf:
	// The ABI return prefix
	byte 0x151f7c75

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute nft_ownerOf(uint64)address
	callsub nft_ownerOf
	concat
	log
	int 1
	return

// nft_ownerOf(_tokenId:uint64): Address
nft_ownerOf:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:44
	// assert(this.tokens(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:45
	// return this.tokens(_tokenId).value.owner;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	retsub

// nft_uri(uint64)string
*abi_route_nft_uri:
	// The ABI return prefix
	byte 0x151f7c75

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute nft_uri(uint64)string
	callsub nft_uri
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// nft_uri(_tokenId:uint64): string
nft_uri:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:49
	// assert(this.tokens(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:50
	// return this.tokens(_tokenId).value.tokenUri;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	int 32
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	retsub

// nft_Image(uint64)string
*abi_route_nft_Image:
	// The ABI return prefix
	byte 0x151f7c75

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute nft_Image(uint64)string
	callsub nft_Image
	dup
	len
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// nft_Image(_tokenId:uint64): string
nft_Image:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:54
	// assert(this.tokens(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:55
	// return this.tokens(_tokenId).value.image;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	int 34
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	extract3
	extract 2 0
	retsub

// nft_totalSupply()uint64
*abi_route_nft_totalSupply:
	// The ABI return prefix
	byte 0x151f7c75

	// execute nft_totalSupply()uint64
	callsub nft_totalSupply
	itob
	concat
	log
	int 1
	return

// nft_totalSupply(): uint64
nft_totalSupply:
	proto 0 1

	// contracts/DNFTLogidtics.algo.ts:59
	// return this.counter.value;
	byte 0x636f756e746572 // "counter"
	app_global_get
	retsub

// nft_getApproved(uint64)address
*abi_route_nft_getApproved:
	// The ABI return prefix
	byte 0x151f7c75

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute nft_getApproved(uint64)address
	callsub nft_getApproved
	concat
	log
	int 1
	return

// nft_getApproved(_tokenId:uint64): Address
nft_getApproved:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:63
	// return this.tokens(_tokenId).value.control;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 36 32
	retsub

// nft_isApprovedForAll(address,address)bool
*abi_route_nft_isApprovedForAll:
	// The ABI return prefix
	byte 0x151f7c75

	// _operator: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 0 (_operator) for nft_isApprovedForAll must be a address
	assert

	// _owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (_owner) for nft_isApprovedForAll must be a address
	assert

	// execute nft_isApprovedForAll(address,address)bool
	callsub nft_isApprovedForAll
	byte 0x00
	int 0
	uncover 2
	setbit
	concat
	log
	int 1
	return

// nft_isApprovedForAll(_owner:Address, _operator:Address): boolean
nft_isApprovedForAll:
	proto 2 1

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/DNFTLogidtics.algo.ts:67
	// control : StaticArray<Address,2> = [_owner,_operator]
	frame_dig -1 // _owner: Address
	frame_dig -2 // _operator: Address
	concat
	frame_bury 0 // control: StaticArray<Address,2>

	// *if2_condition
	// contracts/DNFTLogidtics.algo.ts:68
	// this.approvalAll(control).exists
	frame_dig 0 // control: StaticArray<Address,2>
	box_len
	swap
	pop
	bz *if2_end

	// *if2_consequent
	// contracts/DNFTLogidtics.algo.ts:68
	// return true;
	int 1
	b *nft_isApprovedForAll*return

*if2_end:
	// contracts/DNFTLogidtics.algo.ts:69
	// return false;
	int 0

*nft_isApprovedForAll*return:
	// set the subroutine return value
	frame_bury 0
	retsub

// nft_balaceOf(address)uint64
*abi_route_nft_balaceOf:
	// The ABI return prefix
	byte 0x151f7c75

	// _owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (_owner) for nft_balaceOf must be a address
	assert

	// execute nft_balaceOf(address)uint64
	callsub nft_balaceOf
	itob
	concat
	log
	int 1
	return

// nft_balaceOf(_owner:Address): uint64
nft_balaceOf:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:73
	// assert(this.ownerBox(_owner).exists)
	frame_dig -1 // _owner: Address
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:74
	// return this.ownerBox(_owner).value.length;
	frame_dig -1 // _owner: Address
	box_get

	// box value does not exist: this.ownerBox(_owner).value
	assert
	extract 2 0
	len
	int 8
	/
	retsub

// nft_getAllTokenNftIds(address)uint64[]
*abi_route_nft_getAllTokenNftIds:
	// The ABI return prefix
	byte 0x151f7c75

	// _owner: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (_owner) for nft_getAllTokenNftIds must be a address
	assert

	// execute nft_getAllTokenNftIds(address)uint64[]
	callsub nft_getAllTokenNftIds
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	concat
	log
	int 1
	return

// nft_getAllTokenNftIds(_owner:Address): uint64[]
nft_getAllTokenNftIds:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:78
	// assert(this.ownerBox(_owner).exists)
	frame_dig -1 // _owner: Address
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:79
	// return this.ownerBox(_owner).value;
	frame_dig -1 // _owner: Address
	box_get

	// box value does not exist: this.ownerBox(_owner).value
	assert
	extract 2 0
	retsub

// nft_getTokenDetails(uint64)(address,string,string,address)
*abi_route_nft_getTokenDetails:
	// The ABI return prefix
	byte 0x151f7c75

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute nft_getTokenDetails(uint64)(address,string,string,address)
	callsub nft_getTokenDetails
	concat
	log
	int 1
	return

// nft_getTokenDetails(_tokenId:uint64): token
nft_getTokenDetails:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:83
	// assert(this.tokens(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:84
	// return this.tokens(_tokenId).value;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	retsub

// nft_approve(address,uint64)void
*abi_route_nft_approve:
	// _tokenId: uint64
	txna ApplicationArgs 2
	btoi

	// _approved: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (_approved) for nft_approve must be a address
	assert

	// execute nft_approve(address,uint64)void
	callsub nft_approve
	int 1
	return

// nft_approve(_approved:Address, _tokenId:uint64): void
nft_approve:
	proto 2 0

	// contracts/DNFTLogidtics.algo.ts:88
	// assert(this.tokens(_tokenId).exists)
	frame_dig -2 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:89
	// assert(this.txn.sender===this.tokens(_tokenId).value.owner)
	txn Sender
	frame_dig -2 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	==
	assert

	// contracts/DNFTLogidtics.algo.ts:91
	// this.tokens(_tokenId).value.control = _approved
	frame_dig -2 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	int 36
	frame_dig -1 // _approved: Address
	replace3
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// nft_setApprovalForAll(address,bool)void
*abi_route_nft_setApprovalForAll:
	// _approved: bool
	txna ApplicationArgs 2
	dup
	len
	int 1
	==

	// argument 0 (_approved) for nft_setApprovalForAll must be a bool
	assert
	int 0
	getbit

	// _operator: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 1 (_operator) for nft_setApprovalForAll must be a address
	assert

	// execute nft_setApprovalForAll(address,bool)void
	callsub nft_setApprovalForAll
	int 1
	return

// nft_setApprovalForAll(_operator:Address, _approved:boolean): void
nft_setApprovalForAll:
	proto 2 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/DNFTLogidtics.algo.ts:95
	// control:StaticArray<Address,2> = [this.txn.sender,_operator]
	txn Sender
	frame_dig -1 // _operator: Address
	concat
	frame_bury 0 // control: StaticArray<Address,2>

	// *if3_condition
	// contracts/DNFTLogidtics.algo.ts:97
	// _approved
	frame_dig -2 // _approved: boolean
	bz *if3_else

	// *if3_consequent
	// contracts/DNFTLogidtics.algo.ts:97
	// this.approvalAll(control).value =""
	frame_dig 0 // control: StaticArray<Address,2>
	dup
	box_del
	pop
	byte 0x // ""
	box_put
	b *if3_end

*if3_else:
	// contracts/DNFTLogidtics.algo.ts:98
	// this.approvalAll(control).delete()
	frame_dig 0 // control: StaticArray<Address,2>
	box_del

*if3_end:
	retsub

// nft_upgradeUri(string,uint64)void
*abi_route_nft_upgradeUri:
	// _tokenId: uint64
	txna ApplicationArgs 2
	btoi

	// _tokenUri: string
	txna ApplicationArgs 1
	extract 2 0

	// execute nft_upgradeUri(string,uint64)void
	callsub nft_upgradeUri
	int 1
	return

// nft_upgradeUri(_tokenUri:string, _tokenId:uint64): void
nft_upgradeUri:
	proto 2 0

	// contracts/DNFTLogidtics.algo.ts:102
	// assert(this.tokens(_tokenId).exists)
	frame_dig -2 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:103
	// this.tokens(_tokenId).value.tokenUri=_tokenUri
	frame_dig -2 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	int 32
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	int 0
	load 254 // element start
	substring3
	frame_dig -1 // _tokenUri: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 250 // length difference
	load 251 // element head offset
	int 2
	+ // head ofset
	callsub *update_dynamic_head
	load 255 // full array
	frame_dig -2 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// nft_trasferFrom(address,address,uint64)void
*abi_route_nft_trasferFrom:
	// _tokenId: uint64
	txna ApplicationArgs 3
	btoi

	// _to: address
	txna ApplicationArgs 2
	dup
	len
	int 32
	==

	// argument 1 (_to) for nft_trasferFrom must be a address
	assert

	// _from: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 2 (_from) for nft_trasferFrom must be a address
	assert

	// execute nft_trasferFrom(address,address,uint64)void
	callsub nft_trasferFrom
	int 1
	return

// nft_trasferFrom(_from:Address, _to:Address, _tokenId:uint64): void
nft_trasferFrom:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x
	dup

	// contracts/DNFTLogidtics.algo.ts:107
	// ownerNft = this.tokens(_tokenId).value.owner
	frame_dig -3 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	frame_bury 0 // ownerNft: address

	// contracts/DNFTLogidtics.algo.ts:108
	// control:StaticArray<Address,2> = [ownerNft,this.txn.sender]
	frame_dig 0 // ownerNft: address
	txn Sender
	concat
	frame_bury 1 // control: StaticArray<Address,2>

	// *if4_condition
	// contracts/DNFTLogidtics.algo.ts:110
	// this.txn.sender===this.tokens(_tokenId).value.owner || this.tokens(_tokenId).value.control===this.txn.sender || this.approvalAll(control).exists
	txn Sender
	frame_dig -3 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 0 32
	==
	dup
	bnz *skip_or0
	frame_dig -3 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.tokens(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	extract 36 32
	txn Sender
	==
	||

*skip_or0:
	dup
	bnz *skip_or1
	frame_dig 1 // control: StaticArray<Address,2>
	box_len
	swap
	pop
	||

*skip_or1:
	bz *if4_else

	// *if4_consequent
	// contracts/DNFTLogidtics.algo.ts:111
	// this.transferTo(_to,_tokenId)
	frame_dig -3 // _tokenId: uint64
	frame_dig -2 // _to: Address
	callsub transferTo

	// contracts/DNFTLogidtics.algo.ts:112
	// this.updateTransfer(_from,_to,_tokenId)
	frame_dig -3 // _tokenId: uint64
	frame_dig -2 // _to: Address
	frame_dig -1 // _from: Address
	callsub updateTransfer
	b *if4_end

*if4_else:
	// Not authorized
	err

*if4_end:
	retsub

// mint(string,string,address)void
*abi_route_mint:
	// _to: address
	txna ApplicationArgs 3
	dup
	len
	int 32
	==

	// argument 0 (_to) for mint must be a address
	assert

	// _tokenUri: string
	txna ApplicationArgs 2
	extract 2 0

	// _image: string
	txna ApplicationArgs 1
	extract 2 0

	// execute mint(string,string,address)void
	callsub mint
	int 1
	return

// mint(_image :string, _tokenUri:string, _to:Address): void
mint:
	proto 3 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/DNFTLogidtics.algo.ts:120
	// assert(this.counter.value<1000)
	byte 0x636f756e746572 // "counter"
	app_global_get
	int 1000
	<
	assert

	// contracts/DNFTLogidtics.algo.ts:121
	// assert(this.txn.sender===this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/DNFTLogidtics.algo.ts:131
	// Token :token ={
	//       owner:_to,
	//       tokenUri:_tokenUri,
	//       image:_image,
	//       control:globals.zeroAddress
	//     }
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x0044 // initial head offset
	frame_dig -3 // _to: Address
	callsub *process_static_tuple_element
	frame_dig -2 // _tokenUri: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -1 // _image: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	global ZeroAddress
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // Token: token

	// contracts/DNFTLogidtics.algo.ts:138
	// this.tokens(this.counter.value).value = Token
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig 0 // Token: token
	box_put

	// *if5_condition
	// contracts/DNFTLogidtics.algo.ts:139
	// this.ownerBox(_to).exists
	frame_dig -3 // _to: Address
	box_len
	swap
	pop
	bz *if5_else

	// *if5_consequent
	// contracts/DNFTLogidtics.algo.ts:140
	// this.ownerBox(_to).value.push(this.counter.value)
	frame_dig -3 // _to: Address
	box_get

	// box value does not exist: this.ownerBox(_to).value
	assert
	extract 2 0
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	concat
	frame_dig -3 // _to: Address
	dup
	box_del
	pop
	swap
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put
	b *if5_end

*if5_else:
	// contracts/DNFTLogidtics.algo.ts:142
	// this.ownerBox(_to).value = [this.counter.value]
	frame_dig -3 // _to: Address
	dup
	box_del
	pop
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	dup
	len
	int 8
	/
	itob
	extract 6 2
	swap
	concat
	box_put

*if5_end:
	// contracts/DNFTLogidtics.algo.ts:144
	// this.counter.value = this.counter.value + 1
	byte 0x636f756e746572 // "counter"
	dup
	app_global_get
	int 1
	+
	app_global_put
	retsub

// registerCompany(address)void
*abi_route_registerCompany:
	// _companyAddress: address
	txna ApplicationArgs 1
	dup
	len
	int 32
	==

	// argument 0 (_companyAddress) for registerCompany must be a address
	assert

	// execute registerCompany(address)void
	callsub registerCompany
	int 1
	return

// registerCompany(_companyAddress:Address): void
registerCompany:
	proto 1 0

	// contracts/DNFTLogidtics.algo.ts:148
	// assert(this.txn.sender==this.app.creator)
	txn Sender
	txna Applications 0
	app_params_get AppCreator
	pop
	==
	assert

	// contracts/DNFTLogidtics.algo.ts:149
	// this.registeredCompany(_companyAddress).value = true
	frame_dig -1 // _companyAddress: Address
	int 1
	byte 0x00
	int 0
	uncover 2
	setbit
	box_put
	retsub

// createParcel(string,string,string,string,uint64)void
*abi_route_createParcel:
	// _lastUpdated: uint64
	txna ApplicationArgs 5
	btoi

	// _status: string
	txna ApplicationArgs 4
	extract 2 0

	// _initialLocation: string
	txna ApplicationArgs 3
	extract 2 0

	// _tokenUri: string
	txna ApplicationArgs 2
	extract 2 0

	// _image: string
	txna ApplicationArgs 1
	extract 2 0

	// execute createParcel(string,string,string,string,uint64)void
	callsub createParcel
	int 1
	return

// createParcel(_image :string, _tokenUri:string, _initialLocation:string, _status:string, _lastUpdated:uint64): void
createParcel:
	proto 5 0

	// Push empty bytes after the frame pointer to reserve space for local variables
	byte 0x

	// contracts/DNFTLogidtics.algo.ts:153
	// assert(this.registeredCompany(this.txn.sender).value===true)
	txn Sender
	box_get

	// box value does not exist: this.registeredCompany(this.txn.sender).value
	assert
	int 0
	getbit
	int 1
	==
	assert

	// contracts/DNFTLogidtics.algo.ts:154
	// parcel : parcelStatus = {currentLocation: _initialLocation,status:_status,lastUpdated:_lastUpdated}
	byte 0x // initial head
	byte 0x // initial tail
	byte 0x000c // initial head offset
	frame_dig -3 // _initialLocation: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -4 // _status: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	callsub *process_dynamic_tuple_element
	frame_dig -5 // _lastUpdated: uint64
	itob
	callsub *process_static_tuple_element
	pop // pop head offset
	concat // concat head and tail
	frame_bury 0 // parcel: parcelStatus

	// contracts/DNFTLogidtics.algo.ts:155
	// this.parcelDeatils(this.counter.value).value = parcel
	byte 0x636f756e746572 // "counter"
	app_global_get
	itob
	dup
	box_del
	pop
	frame_dig 0 // parcel: parcelStatus
	box_put

	// contracts/DNFTLogidtics.algo.ts:156
	// this.mint(_image,_tokenUri,this.txn.sender)
	txn Sender
	frame_dig -2 // _tokenUri: string
	frame_dig -1 // _image: string
	callsub mint
	retsub

// updateParcel(uint64,string,string,uint64)void
*abi_route_updateParcel:
	// _lastUpdated: uint64
	txna ApplicationArgs 4
	btoi

	// _status: string
	txna ApplicationArgs 3
	extract 2 0

	// _currentLocation: string
	txna ApplicationArgs 2
	extract 2 0

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute updateParcel(uint64,string,string,uint64)void
	callsub updateParcel
	int 1
	return

// updateParcel(_tokenId:uint64, _currentLocation:string, _status:string, _lastUpdated:uint64): void
updateParcel:
	proto 4 0

	// contracts/DNFTLogidtics.algo.ts:160
	// assert(this.registeredCompany(this.txn.sender).exists)
	txn Sender
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:161
	// assert(this.parcelDeatils(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:162
	// this.parcelDeatils(_tokenId).value.currentLocation=_currentLocation
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.parcelDeatils(_tokenId).value
	assert
	store 255 // full array
	int 0
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	int 0
	load 254 // element start
	substring3
	frame_dig -2 // _currentLocation: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 250 // length difference
	load 251 // element head offset
	int 2
	+ // head ofset
	callsub *update_dynamic_head
	load 255 // full array
	frame_dig -1 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

	// contracts/DNFTLogidtics.algo.ts:163
	// this.parcelDeatils(_tokenId).value.status=_status
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.parcelDeatils(_tokenId).value
	assert
	store 255 // full array
	int 2
	dup
	store 251 // element head offset
	load 255 // full array
	load 255 // full array
	uncover 2
	extract_uint16
	dup
	store 254 // element start
	dup // duplicate start of element
	load 255 // full array
	swap
	extract_uint16 // get number of elements
	int 1 // get type length
	* // multiply by type length
	int 2
	+ // add two for length
	store 253 // element length
	load 255 // full array
	int 0
	load 254 // element start
	substring3
	frame_dig -3 // _status: string
	dup
	len
	itob
	extract 6 2
	swap
	concat
	dup
	store 252 // new element
	load 255 // full array
	load 254 // element start
	load 253 // element length
	+ // get end of Element
	load 255 // full array
	len
	substring3
	concat
	concat
	store 255 // full array
	callsub *get_length_difference
	load 255 // full array
	frame_dig -1 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put

	// contracts/DNFTLogidtics.algo.ts:164
	// this.parcelDeatils(_tokenId).value.lastUpdated=_lastUpdated
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.parcelDeatils(_tokenId).value
	assert
	store 255 // full array
	load 255 // full array
	int 4
	frame_dig -4 // _lastUpdated: uint64
	itob
	replace3
	frame_dig -1 // _tokenId: uint64
	itob
	dup
	box_del
	pop
	swap
	box_put
	retsub

// getParcelDetails(uint64)(string,string,uint64)
*abi_route_getParcelDetails:
	// The ABI return prefix
	byte 0x151f7c75

	// _tokenId: uint64
	txna ApplicationArgs 1
	btoi

	// execute getParcelDetails(uint64)(string,string,uint64)
	callsub getParcelDetails
	concat
	log
	int 1
	return

// getParcelDetails(_tokenId:uint64): parcelStatus
getParcelDetails:
	proto 1 1

	// contracts/DNFTLogidtics.algo.ts:168
	// assert(this.parcelDeatils(_tokenId).exists)
	frame_dig -1 // _tokenId: uint64
	itob
	box_len
	swap
	pop
	assert

	// contracts/DNFTLogidtics.algo.ts:169
	// return this.parcelDeatils(_tokenId).value;
	frame_dig -1 // _tokenId: uint64
	itob
	box_get

	// box value does not exist: this.parcelDeatils(_tokenId).value
	assert
	retsub

// getAppCreatorAddress()address
*abi_route_getAppCreatorAddress:
	// The ABI return prefix
	byte 0x151f7c75

	// execute getAppCreatorAddress()address
	callsub getAppCreatorAddress
	concat
	log
	int 1
	return

// getAppCreatorAddress(): Address
getAppCreatorAddress:
	proto 0 1

	// contracts/DNFTLogidtics.algo.ts:173
	// return this.app.creator;
	txna Applications 0
	app_params_get AppCreator
	pop
	retsub

*create_NoOp:
	method "createApplication(string,string)void"
	txna ApplicationArgs 0
	match *abi_route_createApplication

	// this contract does not implement the given ABI method for create NoOp
	err

*call_NoOp:
	method "nft_ownerOf(uint64)address"
	method "nft_uri(uint64)string"
	method "nft_Image(uint64)string"
	method "nft_totalSupply()uint64"
	method "nft_getApproved(uint64)address"
	method "nft_isApprovedForAll(address,address)bool"
	method "nft_balaceOf(address)uint64"
	method "nft_getAllTokenNftIds(address)uint64[]"
	method "nft_getTokenDetails(uint64)(address,string,string,address)"
	method "nft_approve(address,uint64)void"
	method "nft_setApprovalForAll(address,bool)void"
	method "nft_upgradeUri(string,uint64)void"
	method "nft_trasferFrom(address,address,uint64)void"
	method "mint(string,string,address)void"
	method "registerCompany(address)void"
	method "createParcel(string,string,string,string,uint64)void"
	method "updateParcel(uint64,string,string,uint64)void"
	method "getParcelDetails(uint64)(string,string,uint64)"
	method "getAppCreatorAddress()address"
	txna ApplicationArgs 0
	match *abi_route_nft_ownerOf *abi_route_nft_uri *abi_route_nft_Image *abi_route_nft_totalSupply *abi_route_nft_getApproved *abi_route_nft_isApprovedForAll *abi_route_nft_balaceOf *abi_route_nft_getAllTokenNftIds *abi_route_nft_getTokenDetails *abi_route_nft_approve *abi_route_nft_setApprovalForAll *abi_route_nft_upgradeUri *abi_route_nft_trasferFrom *abi_route_mint *abi_route_registerCompany *abi_route_createParcel *abi_route_updateParcel *abi_route_getParcelDetails *abi_route_getAppCreatorAddress

	// this contract does not implement the given ABI method for call NoOp
	err

*process_static_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -1 // element
	concat
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*process_dynamic_tuple_element:
	proto 4 3
	frame_dig -4 // tuple head
	frame_dig -2 // head offset
	concat
	frame_bury -4 // tuple head
	frame_dig -1 // element
	dup
	len
	frame_dig -2 // head offset
	btoi
	+
	itob
	extract 6 2
	frame_bury -2 // head offset
	frame_dig -3 // tuple tail
	swap
	concat
	frame_bury -3 // tuple tail
	frame_dig -4 // tuple head
	frame_dig -3 // tuple tail
	frame_dig -2 // head offset
	retsub

*update_dynamic_head:
	proto 2 0
	frame_dig -2 // length difference
	load 255 // full array
	frame_dig -1 // dynamic array offset
	extract_uint16 // extract dynamic array offset
	load 249 // subtract head difference
	bz *subtract_head_difference
	+ // add difference to offset
	b *end_calc_new_head

*subtract_head_difference:
	swap
	- // subtract difference from offet

*end_calc_new_head:
	itob // convert to bytes
	extract 6 2 // convert to uint16
	load 255 // full array
	swap
	frame_dig -1 // offset
	swap
	replace3 // update offset
	store 255 // full array
	retsub

*get_length_difference:
	load 252 // new element
	len // length of new element
	load 253 // element length
	<
	bnz *swapped_difference
	load 252 // new element
	len // length of new element
	load 253 // element length
	int 1
	store 249 // subtract head difference
	b *get_difference

*swapped_difference:
	load 253 // element length
	load 252 // new element
	len // length of new element
	int 0
	store 249 // subtract head difference

*get_difference:
	- // get length difference
	store 250 // length difference
	retsub